* ViewModel的基本使用
* Fragment间共享ViewModel
* 原理分析
  * ViewModel 

[TOC]



# 一、ViewModel的基本使用

------

## 1、引入 ViewModel

ViewModel 依赖库的引入，在 androidx 版本中，引入 appcompat 库的时候，其内部就有依赖 ViewModel，所以，基本上都不需要单独引入，只需要引入 appcompat 库就可以了，如：

```groovy
implementation 'androidx.appcompat:appcompat:1.3.1'
```

依赖关系图如下：

![image-20210902202507134](https://gitee.com/meiSThub/BlogImage/raw/master/2020/image-20210902202507134.png)

## 2、使用 ViewModel 

自定义一个 UserViewModel 类，继承与ViewModel：

```kotlin
class UserViewModel : ViewModel() {
  
    fun login(userName: String?, password: String?) {
        ....
    }
}
```

ViewModel 在 MVVM 模式中，充当View 与 Data 的中间层。负责数据的加载与处理。

在 Activity/Fragment 中，使用 ViewModel ：

```kotlin
class UserActivity : AppCompatActivity() {

  // 初始化 UserViewModel
    private val viewModel by lazy {
        ViewModelProvider(this@UserActivity).get(UserViewModel::class.java)
    }
  
  	private fun login(userName: String?, password: String?){
	      viewModel.login(userName,password)
    }
}
```

从上面的代码可以看出，ViewModel 对象的创建，是借助 ViewModelProvider 类的 get 方法进行创建的。虽然也可以直接通过 new 的方式创建 ViewModel 对象，但只有通过 ViewModelProvider 类创建的ViewModel 对象的方式，才能发挥出 ViewModel 真正的优势。

### ViewModel 的优势主要有如下几点：

* ViewModel 的生命周期 长于 Activity

* 不持有 UI 层的引用

* 在因配置信息改变而导致Activity重启的时候，ViewModel 不会被销毁，使 ViewModel 中的数据得以保存，比 onSaveInstanceState()

  方法存储的数据更加复杂

* ViewModel 生命周期管理，在 Activity/Fragment 真正销毁的时候，系统会自动调用 ViewModel 的 clear() 方法，释放资源。



## 3、Fragment 之间，共享Activity 的 ViewModel 对象

Fragment 之间，共享 Activity 的 ViewModel 对象，主要有两种方式：

* （1）直接通过 ViewModelProvider 的 get 方法，获取 Activity 的 ViewModel 对象

  ```kotlin
  class MyFragment : Fragment() {
  
      fun getActivityViewModel() {
        // ViewModelProvider 的构造函数传 Activity 对象，get 方法的类型 传 Activity 的ViewModel 类型
        // 获取到的就是 Activity 的 ViewModel 对象
          val activityViewModel = ViewModelProvider(requireActivity()).get(LiveDataViewModel::class.java)
      }
  }
  ```

* （2）通过 Fragment 的扩展方法获取 Activity 的 ViewModel 对象

  ```kotlin
  class MyFragment : Fragment() {
  
      fun getActivityViewModel() {
        // 通过 Fragment 的 扩展函数 activityViewModels()，获取 Activity 的ViewModel 对象
          val activityViewModel = activityViewModels<LiveDataViewModel>()
      }
  }
  ```

  这种方式获取 Activity 的 ViewModel 对象，需要引入 Fragment 的 扩展库：

  ```groovy
  dependencies {
      implementation "androidx.fragment:fragment-ktx:1.3.6"
  }
  ```

以上两种方式，在 Fragment 中都可以获取到 宿主Activity 的 ViewModel 对象，这两种方式都不会重新创建 Activity 的 ViewModel 对象，获取到的对象还是 Activity 自己创建的那个 ViewModel 对象，这样就实现了 Fragment 间，共享 Activity 的ViewModel 。

# 二、原理分析

------

通过上面的介绍，我们知道了 ：

* （1）在 Activity 的配置信息发生变化导致的 Activity 重建，ViewModel 对象是不会销毁的
* （2）在 Fragment 间可以共享 Activity 的 ViewModel 对象，而不会重新创建 ViewModel 对象
* （3）在 Activity 真正销毁的时候，ViewModel 也会自动销毁，即系统自动用 ViewModel 的 clear() 方法，进行资源的释放。

那么上面这些功能，ViewModel 是如何实现的呢？下面我们就借助源码，来分析一下。

## 1、ViewModel 的创建

通过 ViewModel 基本的使用，我们知道 ViewModel 对象的创建，是通过 ViewModelProvider 类的 get 方法来创建的。

### 1-1、ViewModelProvider 对象的创建

首先，来看看 ViewModelProvider 的构造函数，我们一般调用的是 ViewModelProvider 一个参数的构造函数：

```java
public ViewModelProvider(@NonNull ViewModelStoreOwner owner) {
    this(owner.getViewModelStore(), owner instanceof HasDefaultViewModelProviderFactory
            ? ((HasDefaultViewModelProviderFactory) owner).getDefaultViewModelProviderFactory()
            : NewInstanceFactory.getInstance());
}

public ViewModelProvider(@NonNull ViewModelStore store, @NonNull Factory factory) {
    mFactory = factory;
    mViewModelStore = store;
}
```

在一个参数的构造函数内部，调用了 两个参数的构造函数，传递了 ViewModelStore 对象和 Factory 对象。

在 Activity/Fragment 中，我们一般传的都是 this 对象，即 Activity/Fragment 对象本身，这是因为 Activity/Fragment 就实现了 ViewModelStoreOwner 接口，如ComponentActivity：

```java
public class ComponentActivity extends androidx.core.app.ComponentActivity implements
        ContextAware,
        LifecycleOwner,
        ViewModelStoreOwner,
        HasDefaultViewModelProviderFactory,
        SavedStateRegistryOwner,
        OnBackPressedDispatcherOwner,
        ActivityResultRegistryOwner,
        ActivityResultCaller {
        
        public ViewModelStore getViewModelStore() {
            if (getApplication() == null) {
                throw new IllegalStateException("Your activity is not yet attached to the "
                        + "Application instance. You can't request ViewModel before onCreate call.");
            }
            ensureViewModelStore();
            return mViewModelStore;
    		}
          
       public ViewModelProvider.Factory getDefaultViewModelProviderFactory() {
            if (getApplication() == null) {
              throw new IllegalStateException("Your activity is not yet attached to the "
                                              + "Application instance. You can't request ViewModel before onCreate call.");
            }
            if (mDefaultFactory == null) {
            	  mDefaultFactory = new SavedStateViewModelFactory(getApplication(),  this,
               																	 getIntent() != null ? getIntent().getExtras() : null);
            }
            return mDefaultFactory;
         }
}
```

ComponentActivity 除了实现了ViewModelStoreOwner 接口外，还实现了 HasDefaultViewModelProviderFactory 接口，所以 ViewModelProvider 的第二个参数，就是 SavedStateViewModelFactory 对象。

所以，ViewModelProvider 默认情况下，使用的 Factory 就是 SavedStateViewModelFactory 对象。

### 1-2、ViewModel 对象的创建

创建了 ViewModelProvider 对象之后，调用 get 方法创建 ViewModel 对象：

```java
private static final String DEFAULT_KEY = "androidx.lifecycle.ViewModelProvider.DefaultKey";

public <T extends ViewModel> T get(@NonNull Class<T> modelClass) {
  // 1. 获取类对象的完整类名
    String canonicalName = modelClass.getCanonicalName();
    if (canonicalName == null) {// 类名为空，报异常
        throw new IllegalArgumentException("Local and anonymous classes can not be ViewModels");
    }
  // 2. 通过默认前缀 + 类名，组成 key，即：androidx.lifecycle.ViewModelProvider.DefaultKey:包名.类名
    return get(DEFAULT_KEY + ":" + canonicalName, modelClass);
}

@SuppressWarnings("unchecked")
@NonNull
@MainThread
public <T extends ViewModel> T get(@NonNull String key, @NonNull Class<T> modelClass) {
  	// 1.通过 key 值，在 ViewModelStore 中 获取 ViewModel 对象
    ViewModel viewModel = mViewModelStore.get(key);
	  // 2.如果 获取到的 ViewModel 对象是给定类型的 对象
    if (modelClass.isInstance(viewModel)) {
        if (mFactory instanceof OnRequeryFactory) {
          // 回调 OnRequeryFactory 的 onRequery 方法
            ((OnRequeryFactory) mFactory).onRequery(viewModel);
        }
        return (T) viewModel;
    } else {
        //noinspection StatementWithEmptyBody
        if (viewModel != null) {
            // TODO: log a warning.
        }
    }
  // 3.判断Factory 的类型，从ViewModelProvider 对象的创建知道，mFactory对象 是 SavedStateViewModelFactory 类型，而
  // SavedStateViewModelFactory 类继承了 KeyedFactory 类，所以这里判断是为true
    if (mFactory instanceof KeyedFactory) {
      // 调用 SavedStateViewModelFactory 的 create 方法。
        viewModel = ((KeyedFactory) mFactory).create(key, modelClass);
    } else {
        viewModel = mFactory.create(modelClass);
    }
  // 4.把创建的 ViewModel 对象，缓存到 ViewModelStore 对象中
    mViewModelStore.put(key, viewModel);
    return (T) viewModel;
}
```

分析上面的代码，可以看出，get方法的逻辑主要包含如下方面：

* （1）从 ViewModelStore 对象中，根据 ViewModel 的 Key 值，获取缓存的 ViewModel 对象。
* （2）从 判断获取到的 ViewModel 对象，是否为给定 类类型的对象，如果是，则返回缓存的 ViewModel 对象。
* （3）调用 Factory 类的 create 方法，创建 ViewModel 对象。
* （4）把创建的 ViewModel 对象，缓存到 ViewModelStore 对象中。

从上的分析就可以知道，Fragment 之间为什么可以共享 Activity 的 ViewModel 对象，而不会重新创建 ViewModel 对象，因为ViewModel 在创建之后，就缓存到了 ViewModelStore 中，当下次通过 ViewModelProvider 获取相同类的 ViewModel 对象的时候，就直接冲 ViewModelStore 缓存中获取到 ViewModel 对象了，所以才不会重新状态 ViewModel 对象。

下面在看看 SavedStateViewModelFactory  类的 create 方法，是如何创建 ViewModel 对象的。

### 1-3、SavedStateViewModelFactory 的 create方法，创建ViewModel 对象

```java
public <T extends ViewModel> T create(@NonNull String key, @NonNull Class<T> modelClass) {
    boolean isAndroidViewModel = AndroidViewModel.class.isAssignableFrom(modelClass);
    Constructor<T> constructor;
    if (isAndroidViewModel && mApplication != null) {
      // 查找 ViewModel 是否有 两个参数的构造函数，参数类型是：Application，SavedStateHandle
        constructor = findMatchingConstructor(modelClass, ANDROID_VIEWMODEL_SIGNATURE);
    } else {
      // 查找 ViewModel 是否有 一个 SavedStateHandle 参数的构造函数
        constructor = findMatchingConstructor(modelClass, VIEWMODEL_SIGNATURE);
    }
    // doesn't need SavedStateHandle
    if (constructor == null) {
      // 如果没有找到指定的构造函数，则调用 mFactory 的create 方法，创建 ViewModel 对象
        return mFactory.create(modelClass);
    }

  // 创建 SavedStateHandleController 对象
    SavedStateHandleController controller = SavedStateHandleController.create(
            mSavedStateRegistry, mLifecycle, key, mDefaultArgs);
    try {
        T viewmodel;
        if (isAndroidViewModel && mApplication != null) {
          // 通过 SavedStateHandleController 对象，获取 SavedStateHandle 对象
            viewmodel = constructor.newInstance(mApplication, controller.getHandle());
        } else {
            viewmodel = constructor.newInstance(controller.getHandle());
        }
        viewmodel.setTagIfAbsent(TAG_SAVED_STATE_HANDLE_CONTROLLER, controller);
        return viewmodel;
    } catch (IllegalAccessException e) {
        throw new RuntimeException("Failed to access " + modelClass, e);
    } catch (InstantiationException e) {
        throw new RuntimeException("A " + modelClass + " cannot be instantiated.", e);
    } catch (InvocationTargetException e) {
        throw new RuntimeException("An exception happened in constructor of "
                + modelClass, e.getCause());
    }
}
```

如果 ViewModel 的构造函数中，有一个 SavedStateHandle 参数，就会调用这个 构造函数，并传入 SavedStateHandle 对象。

这里主要是为了保留 onSaveInstanceState() 方法类似的功能。

而默认情况下，我们没有提供 有 SavedStateHandle 参数的构造函数，所以这里不会走下面的创建 ViewModel 的逻辑，即 constructor 是空的，这个时候就会去调用 mFactory 的 create 方法，而 mFactory 对象是 什么类型呢？ 

查看 SavedStateViewModelFactory 的构造函数可以看到 mFactory 的初始化：

```java
public SavedStateViewModelFactory(@Nullable Application application,
        @NonNull SavedStateRegistryOwner owner,
        @Nullable Bundle defaultArgs) {
    mSavedStateRegistry = owner.getSavedStateRegistry();
    mLifecycle = owner.getLifecycle();
    mDefaultArgs = defaultArgs;
    mApplication = application;
  // application 是不为空的，所以 mFactory 是 AndroidViewModelFactory 类型
    mFactory = application != null
            ? ViewModelProvider.AndroidViewModelFactory.getInstance(application)
            : ViewModelProvider.NewInstanceFactory.getInstance();
}
```

### 1-4、AndroidViewModelFactory 的 create 方法，创建 ViewModel 对象

```java
public <T extends ViewModel> T create(@NonNull Class<T> modelClass) {
    if (AndroidViewModel.class.isAssignableFrom(modelClass)) {
        //noinspection TryWithIdenticalCatches
        try {
          // 这里去获取 ViewModel 带 Application 参数的构造函数，默认情况下，ViewModel 都是没有提供这样的构造函数的
            return modelClass.getConstructor(Application.class).newInstance(mApplication);
        } catch (NoSuchMethodException e) {
            throw new RuntimeException("Cannot create an instance of " + modelClass, e);
        } catch (IllegalAccessException e) {
            throw new RuntimeException("Cannot create an instance of " + modelClass, e);
        } catch (InstantiationException e) {
            throw new RuntimeException("Cannot create an instance of " + modelClass, e);
        } catch (InvocationTargetException e) {
            throw new RuntimeException("Cannot create an instance of " + modelClass, e);
        }
    }
    return super.create(modelClass);
}
```

ViewModel 带 Application 参数的构造函数，默认情况下，ViewModel 都是没有提供这样的构造函数的，所以这里会走到父类的 create 方法，而 AndroidViewModelFactory 的父类就是 NewInstanceFactory 类。

### 1-5、NewInstanceFactory 的 create 方法，创建 ViewModel 对象

```java
public <T extends ViewModel> T create(@NonNull Class<T> modelClass) {
    //noinspection TryWithIdenticalCatches
    try {
      // 这就就直接通过反射，创建 ViewModel 对象了
        return modelClass.newInstance();
    } catch (InstantiationException e) {
        throw new RuntimeException("Cannot create an instance of " + modelClass, e);
    } catch (IllegalAccessException e) {
        throw new RuntimeException("Cannot create an instance of " + modelClass, e);
    }
}
```

到此，默认情况下，ViewModel 对象的创建，最终调用到了 NewInstanceFactory 类的 create 方法，通过反射的方式，调用无参的构造函数进行对象的创建。

