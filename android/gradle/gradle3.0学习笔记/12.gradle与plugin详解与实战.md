## Settings类
Settings类的对象，是通过settings.gradle配置文件去初始化的。所以我们可以在settings.gradle配置文件中，
去调用Settings的属性和方法。
gradle的初始化操作，就是执行的settings.gradle中的内容，通过settings.gradle中的配置，决定有
多少个工程需要被处理与配置。

## SourceSet类
SourceSet类决定类我们的工程，第三方插件等源码和库存放的路径。gradle 默认就是从我们module的java路径下去找源码，
从res目录下获取资源文件进行编译。

* 指定jar包位置
``` java
sourceSets {
        main {
            jniLibs.srcDirs=['libs'] // 指定jar的位置
        }
    }
```


* 指定资源文件路径

可以有效的根据我们项目中的模块，定义不同的资源文件路径，方便管理

``` java
sourceSets {
        main {
            res.srcDirs = ['src/main/res',
                           'src/main/res-ad',
                           'src/main/res-play']
        }
    }
```

sourceSets 是可以多次调用的。

sourceSets除了可以放在android闭包内部，也可以在外部调用android对象，为其设置：sourceSets，如：
``` java
this.android.sourceSets{
    main {
        res.srcDirs = ['src/main/res',
                       'src/main/res-ad',
                       'src/main/res-play']
    }
}
```

## 插件：Plugin
我们可以将完成特定任务的task都封装在某一个插件当中，这样别人只需要引入我们开发的插件，就可以完成特定的功能。
就比如我们用到的：java插件，Android插件，library插件等。

使用java插件，我们可以把工程打成jar包，使用Android插件，可以把工程打成apk，library插件可以把工程达成aar包（针对Android模块）

这就是plugin最重要的作用，对task的封装。

##### plugin的创建
在Android Studio中，创建一个独立的plugin 模块，步骤如下：
1. 创建一个java library 模块：在 Android Studio 中新建 Java Library module “plugin”。
2. 修改 build.gradle 文件
``` java
apply plugin: 'groovy' // 引入groovy插件

// 重置源码路径
sourceSets{
    main{
        groovy{
            srcDir 'src/main/groovy'
        }

        resources {
            srcDir 'src/main/resources'
        }
    }
}

// 添加gradle api依赖
dependencies {
    implementation gradleApi()
}

```
3. 修改项目文件夹
* 移除 java 文件夹，因为在这个项目中用不到 java 代码
* 添加 groovy 文件夹，主要的代码文件放在这里
* 添加 resources 文件夹，存放用于标识 gradle 插件的 meta-data

经过这样三步之后，plugin工程创建就完成了

## plugin 实现
1. Build script

把插件写在 build.gradle 文件中，一般用于简单的逻辑，只在该 build.gradle 文件中可见

2. buildSrc 项目

将插件源代码放在 rootProjectDir/buildSrc/src/main/groovy 中，只对该项目中可见，适用于逻辑较为复杂，但又不需要外部可见的插件，可以参见[img-optimizer-gradle-plugin](https://github.com/chenenyu/img-optimizer-gradle-plugin)

3. 独立项目

一个独立的 Groovy 和 Java 项目，可以把这个项目打包成 Jar 文件包，一个 Jar 文件包还可以包含多个插件入口，将文件包发布到托管平台上，供其他人使用。本文将着重介绍此类。

##### Build Script ：直接把插件写在项目的gradle文件中
把插件写在build.gradle文件中,这种是最简单的插件开发方式。

``` java

apply plugin: GreetingPlugin // 引用插件，直接

// 扩展属性 这个是我们在插件：GreetingPlugin 中，为Project对象创建的扩展属性
greetingExtension {
    versionCode 1000
    versionName '1.0.0'
    versionInfo '第一个greetingPlugin版本'
}

// 插件：GreetingPlugin，所需要的调用者提供的额外信息
class GreetingPluginExtension {

    int versionCode

    String versionName

    String versionInfo
}

/**
* 插件类
*/
class GreetingPlugin implements Plugin<Project> {

    @Override
    void apply(Project project) {
        def extension =  project.extensions.create('greetingExtension', GreetingPluginExtension)
        project.task('greetingPlugin') {
            group 'mytask'
            doLast {
                println "versionCode=${extension.versionCode} versionName is ${extension.versionName}" +
                        "versionInfo is ${extension.versionInfo}"
            }
        }
    }
}
```
这种方式非常简单，直接把插件写在build.gradle文件中，引用的时候，直接引用插件名即可，如：
apply plugin: 插件名（在build.gradle中定义的插件）

实现的插件只能给当前的Project使用


#####  buildSrc 项目
实现步骤：
* 在工程中建立一个：buildSrc 文件夹
* 在buildSrc下，建立** src** 文件夹 和build.gradle文件
* 在** src** 文件夹下，建立 **main/groovy** 和 **main/resources** 文件夹
* 在**groovy**文件夹下，建立包名，编写插件源码，Android Studio中无法直接创建Groovy类，只能创建文件，把后缀名改成 **.groovy**
* 在**resources**文件夹下，继续创建**META-INF/gradle-plugins**文件夹，然后在该目录下创建：**插件名.properties** 文件，插件名一般以插件的包名命名，在该文件中，指定插件实现类，如：com.mei.buildsrc.plugin.properties
``` java
implementation-class=com.mei.buildsrc.plugin.ManagerVersionPlugin
```
* 修改build.gradle文件，引入groovy插件，修改源码路径，如下：
``` java
apply plugin: 'groovy'

sourceSets {
    main {
        groovy {
            srcDirs 'src/main/groovy'
        }

        resources {
            srcDirs 'src/main/resources'
        }
    }
}
```

插件类需要实现Plugin接口，泛型为Project
插件代码：
``` java
package com.mei.buildsrc.plugin

import org.gradle.api.Plugin
import org.gradle.api.Project

// 实现Plugin插件接口
class ManagerVersionPlugin implements Plugin<Project> {

    @Override
    void apply(Project project) {
      // 为引用该插件的Project创建扩展属性和task
        project.extensions.create("helloReleaseInfo", ReleaseInfoExtension)
        // 为Project创建一个名为：HelloPluginTask的task，类型为：HelloPluginTask，即我们实现的task类
        project.tasks.create("HelloPluginTask", HelloPluginTask)
    }
}
```
插件就是task的集合，所以插件的任务一般都是分配给task去执行的，task实现如下：
``` java
package com.mei.buildsrc.plugin

import groovy.xml.MarkupBuilder
import org.gradle.api.DefaultTask
import org.gradle.api.tasks.TaskAction

class HelloPluginTask extends DefaultTask {

    HelloPluginTask() {
        group = "mytask"
        description = 'hello plugin task'
    }

    @TaskAction
    void doAction() {
        println('update version info begin....')
        updateInfo()
        println('update finished...')
    }

    /**
     * 把版本信息写入到文件当中
     */
    private void updateInfo() {
        println '开始写入版本信息'

        String versionCodeMsg = project.extensions.helloReleaseInfo.versionCode
        String versionNameMsg = project.extensions.helloReleaseInfo.versionName
        String versionInfoMsg = project.extensions.helloReleaseInfo.versionInfo
        String fileName = project.extensions.helloReleaseInfo.fileName

        println project.extensions.helloReleaseInfo

        // 获取到输入信息
        def file = project.file(fileName)

        if (file != null && !file.exists()) {
            file.createNewFile()
        }

        def stringWriter = new StringWriter();
        def xmlBuilder = new MarkupBuilder(stringWriter)
        println "file----${file.text} size=${file.text.size()}"
        // 文件是空的
        if (file.text != null && file.text.size() <= 0) {
            // 通过MarkupBuilder把数据以xml的格式，写入到StringWriter中
            println '文本是空的，从头写入'
            xmlBuilder.releases {
                release {
                    versionCode(versionCodeMsg)
                    versionName(versionNameMsg)
                    versionInfo(versionInfoMsg)
                }
            }
            println '写入到builder当中'
            // 把数据写入到文件中
            file.withWriter { writer ->
                writer.append(stringWriter.toString())
            }

            println '空，写完'
        } else { // 如果文件已经有了内容，则追加

            println '文件有内容'

            def lines = file.readLines() // 读取文件所有行
            def lastLine = lines.size() - 1; // 文件最后一行

            xmlBuilder.release {
                versionName(versionNameMsg)
                versionCode(versionCodeMsg)
                versionInfo(versionInfoMsg)
            }

            println 'xml 文件构建完成'
            // 遍历每一行，并写入到文件中

            file.withWriter { writer ->
                lines.eachWithIndex { String line, int index ->
                    if (index != lastLine) {// 如果不是最后一行，直接写入
                        writer.append(line).append("\r\n") // 每一行写完，换行
                    } else { //如果是最后一行，则先把我们新增加的内容写入，在写入最后一行
                        writer.append(stringWriter.toString()).append("\r\n")
                        writer.append(line).append('\r\n')
                    }
                }
            }

            println '写完'
        }

        println '版本信息写入完成...'
    }
}
}
```
 实体类对象，让调用者可以更好的为插件提供配置信息
``` java
package com.mei.buildsrc.plugin

class ReleaseInfoExtension {

    int versionCode

    String versionName

    String versionInfo

    String fileName// 版本信息保存的文件名

    @Override
    String toString() {
        return """
        versionCode='${versionCode}'
        versionName='${versionName}'
        versionInfo='${versionInfo}'
        fileName='${fileName}'
"""
    }
```

以上就是写完了一个插件，但该插件我们只能在我们定义他的模块中使用，如在app模块中引入该插件：
``` java
apply plugin: 'com.mei.buildsrc.plugin'

// 使用该插件，需要给插件配置的信息
helloReleaseInfo {
    versionName '1.1.0'
    versionCode 120
    versionInfo '发布Hello第3个稳定版本'
    fileName 'helloreleaseinfo.xml'
}
```

这样就可以使用我们定义的插件了，在Android studio中的task列表中，就可以在mytask分组中看到我们定以的task：HelloPluginTask了，

源码地址：




## Android对gradle的扩展
Android工程，我们都可以在android闭包中的对其进行配置，可以配置的东西如下：
| 名称              | 描述 |
| ----------------- | ---- |
| compileSdkVersion | 配置Android编译版本     |
