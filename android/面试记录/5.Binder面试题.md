进程间通信的方式：

| 方式     | 特点 | 性能 | 安全性 |
| -------- | ---- | ---- | ------ |
| 管道     |      |      |        |
| 共享内存 |      |      |        |
| 文件     |      |      |        |
| Socket   |      |      |        |
| Binder   |      |      |        |

![image-20210222202150641](https://raw.githubusercontent.com/meiSThub/BlogImage/master/2020/image-20210222202150641.png)





内核空间：运行系统的代码

用户空间：运行用户的代码



物理地址：

虚拟地址：





1. 关于拷贝 下列哪些点 描述的是错误的



1 管道 拷贝两次

2 共享内存拷贝一次

3 Binder通信拷贝一次

4 Socket拷贝两次



这题正确答案是 2  共享内存，是0次拷贝，管道有两次拷贝哦	



2. 当通过Class.forName("com.maniu.Test")加载一个类时

Class字节码有没有全部加载到物理内存

1 有

2 没有

3 部分加载



这一题是选3部分加载， 此时的class 是存储在磁盘中的， jvm的类加载 是基于 linux 最基本的 内存与磁盘之间交换机制展开的

在所有的程序中，到物理内存的数据 都是活跃的时候，加载，不活跃的就不加载呢，小伙伴们 一定要记住哦



3. 物理内存和磁盘交互数据时，是多少整数倍

1  1k

2  2k

3  4k

4  8k



4k



Intent在异步情况下 ，最大支持多少数据

1 1M

2 512k

3 1M-8K/2

4 (1M-8K)/2



答案：4



异步情况下， 传递数据大小是 正常情况的一半 呢



这个是binder驱动层被限制了，异步在一个进程好处理，是不同线程传递数据罢了，

如果异步放在不同进程，首先需要确保找到目标进程，然后再进程中找到对应线程，最后回调该线程的 服务方法，这些过程耗费的时间 大于同步的时间，binder驱动内存优势有限的



binder 内核空间中开辟物理内存本身比较宝贵，打个比方 如果一次通信占用1M大小 占用 1s中时间，而异步 占用1M大小 占用2s中时间。 这些映射的物理内存需要频繁的使用的，为了减少异步长时间占用， 所以只能有一种折中的方案，占用0.5M 大小 占用2s钟时间