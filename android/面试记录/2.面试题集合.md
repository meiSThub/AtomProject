### 面试题：https://segmentfault.com/u/foyue/articles?page=1
handler相关：https://www.jianshu.com/p/ea7beaeeee16


###### 1.FragmentPagerAdapter 与 与 FragmentStatePagerAdapter 的区别与使用场景？
参考答案：FragmentPagerAdapter 的每个 Fragment 会持久的保存在 FragmentManager 中，只要用户可以返回到页面中，它都不会被销毁。因此适用于那些数据 相对静态的页，Fragment 数量也比较少的那种;FragmentStatePagerAdapter 只保留当前页面，当页面不可见时，该 Fragment 就会被消除，释放其资源。因此适用于那些 数据动态性较大、 占用内存较多，多 Fragment 的情况；



## 2. 类加载的过程是什么样的？

类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。

1、加载

”加载“是”类加机制”的第一个过程，在加载阶段，虚拟机主要完成三件事：

（1） 通过一个类的全限定名来获取其定义的二进制字节流

（2） 将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构

（3） 在堆中生成一个代表这个类的Class对象，作为方法区中这些数据的访问入口。

2、验证

验证的主要作用就是确保被加载的类的正确性。也是连接阶段的第一步。说白了也就是我们加载好的.class文件不  能对我们的虚拟机有危害，所以先检测验证一下。他主要是完成：文件格式的验证 、元数据验证 、字节码验证 、符号引用验证 。

3、准备

准备阶段主要为类变量分配内存并设置初始值（数据类型默认值，而不是代码中被显示赋予的值 ）。

4、解析

解析阶段主要是虚拟机将常量池中的符号引用转化为直接引用的过程。

5、初始化



### 3.如何避免OOM?

在初始化阶段，主要为类的静态变量赋予正确的初始值

①声明类变量是指定初始值

②使用静态代码块为类变量指定初始值



1.使用更加轻量的数据结构：如使用 ArrayMap/SparseArray 替代HashMap,HashMap 更耗内存，因为它需要额外的实例对象来记录 Mapping 操作，SparseArray 更加高效，因为它避免了 Key Value 的自动装箱，和装箱后的解箱操作

2.便面枚举的使用，可以用静态常量或者注解@IntDef 替代

Bitmap 优化:

a.尺寸压缩：通过 InSampleSize 设置合适的缩放

b.颜色质量：设置合适的format，ARGB_6666/RBG_545/ARGB_4444/ALPHA_6， 存在很大差异

c.inBitmap:使用 inBitmap 属性可以告知 Bitmap 解码器去尝试使用已经存在的内存区域，新解码的Bitmap 会尝试去使用之前那张Bitmap 在Heap 中所占据的pixel

data 内存区域，而不是去问内存重新申请一块区域来存放 Bitmap。利用这种特性，

即使是上千张的图片，也只会仅仅只需要占用屏幕所能够显示的图片数量的内存大小， 但复用存在一些限制，具体体现在：在Android 4.4 之前只能重用相同大小的 Bitmap 的内存，而 Android 4.4 及以后版本则只要后来的 Bitmap 比之前的小即可。使用 inBitmap 参数前，每创建一个 Bitmap 对象都会分配一块内存供其使用，而使用了 inBitmap 参数后，多个 Bitmap 可以复用一块内存，这样可以提高性能

StringBuilder 替代 String: 在有些时候，代码中会需要使用到大量的字符串拼接的操作，这种时候有必要考虑使用 StringBuilder 来替代频繁的“+”

3.避免在类似 onDraw 这样的方法中创建对象，因为它会迅速占用大量内存，引起频繁的 GC 甚至内存抖动

4.减少内存泄漏也是一种避免 OOM 的方法



### 4.什么导致线程阻塞？线程如何关闭？

阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket 的

accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。

一种是调用它里面的 stop()方法

另一种就是你自己设置一个停止线程的标记 （推荐这种）



### 5.数据库的四大特征，数据库的隔离级别？

事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列， 这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。例如，银 行转账工作：从一个账号扣款并使另一个账号增款，这两个操作要么都执行，要 么都不执行。所以，应该把它们看成一个事务。事务是数据库维护数据一致性的 单位，在每个事务结束时，都能保持数据一致性。

事务具有以下 4 个基本特征：数据库的四大特征：

（1）原子性（Atomicity）

原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。

（2）一致性（Consistency）

一个事务执行之前和执行之后都必须处于一致性状态。

（3）隔离性（Isolation）

 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个 用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。

（4）持久性（Durability）

 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性 的。

数据库的隔离级别：

1）Serializable(串行化)：可避免脏读、不可重复读、幻读的发生。

2）Repeatable read (可重复读)：可避免脏读、不可重复读的发生。

3）Read committed (读已提交)：可避免脏读的发生。

4）Read uncommitted (读未提交)：最低级别，任何情况都无法保证。



### 6.通过静态内部类实现单例模式有哪些优点？

1. 不用 synchronized ，节省时间。

2. 调用 getInstance() 的时候才会创建对象，不调用不创建，节省空间，这 有点像传说中的懒汉式。

   

### 7.Hashmap 底层为什么是线程不安全的？

并发场景下使用时容易出现死循环，在 HashMap 扩容的时候会调用 resize() 方法，就是这里的并发操作容易在一个桶上形成环形链表；这样 当获取一个不存在的 key 时，计算出的 index 正好是环形链表的下标就 会出现死循环；· 在 1.7 中 hash 冲突采用的头插法形成的链表，在并发条件下会形成循 环链表，一旦有查询落到了这个链表上，当获取不到值时就会死循环。



### 8.服务启动一般有几种，服务和 activty 之间怎么通信，服务和服务之间怎么通信

* 1、startService：onCreate()--->onStartCommand() ---> onDestory() 如果服务已经开启，不会重复的执行 onCreate()， 而是会调用 onStartCommand()。一旦服务开启跟调用者(开启者)就没有任何关系了。开启 者退出了，开启者挂了，服务还在后台长期的运行。开启者不能调用服务里面 的方法。
* 2、bindService：onCreate() --->onBind()--->onunbind()--->onDestory() bind 的方式开启服务，绑定服务，调用者挂了，服务也会跟着挂掉。绑定者可 以调用服务里面的方法。
* 3、通信：
  * 通过 Binder 对象。
  * 通过 broadcast(广播)。