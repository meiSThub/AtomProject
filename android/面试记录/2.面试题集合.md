### 面试题：https://segmentfault.com/u/foyue/articles?page=1

handler相关：https://www.jianshu.com/p/ea7beaeeee16

[wanandroid/面试资料汇总](http://www.wanandroid.com/article/list/0?cid=73)

Android知识体系：https://juejin.im/entry/6844903598132822029






###### 1.FragmentPagerAdapter 与 与 FragmentStatePagerAdapter 的区别与使用场景？

参考答案：FragmentPagerAdapter 的每个 Fragment 会持久的保存在 FragmentManager 中，只要用户可以返回到页面中，它都不会被销毁。因此适用于那些数据 相对静态的页，Fragment 数量也比较少的那种;FragmentStatePagerAdapter 只保留当前页面，当页面不可见时，该 Fragment 就会被消除，释放其资源。因此适用于那些 数据动态性较大、 占用内存较多，多 Fragment 的情况；



## 2. 类加载的过程是什么样的？

类加载的过程包括了加载、验证、准备、解析、初始化五个阶段。

1、加载

”加载“是”类加机制”的第一个过程，在加载阶段，虚拟机主要完成三件事：

（1） 通过一个类的全限定名来获取其定义的二进制字节流

（2） 将这个字节流所代表的的静态存储结构转化为方法区的运行时数据结构

（3） 在堆中生成一个代表这个类的Class对象，作为方法区中这些数据的访问入口。

2、验证

验证的主要作用就是确保被加载的类的正确性。也是连接阶段的第一步。说白了也就是我们加载好的.class文件不  能对我们的虚拟机有危害，所以先检测验证一下。他主要是完成：文件格式的验证 、元数据验证 、字节码验证 、符号引用验证 。

3、准备

准备阶段主要为类变量分配内存并设置初始值（数据类型默认值，而不是代码中被显示赋予的值 ）。

4、解析

解析阶段主要是虚拟机将常量池中的符号引用转化为直接引用的过程。

5、初始化



### 3.如何避免OOM?

在初始化阶段，主要为类的静态变量赋予正确的初始值

①声明类变量是指定初始值

②使用静态代码块为类变量指定初始值



1.使用更加轻量的数据结构：如使用 ArrayMap/SparseArray 替代HashMap,HashMap 更耗内存，因为它需要额外的实例对象来记录 Mapping 操作，SparseArray 更加高效，因为它避免了 Key Value 的自动装箱，和装箱后的解箱操作

2.便面枚举的使用，可以用静态常量或者注解@IntDef 替代

Bitmap 优化:

a.尺寸压缩：通过 InSampleSize 设置合适的缩放

b.颜色质量：设置合适的format，ARGB_6666/RBG_545/ARGB_4444/ALPHA_6， 存在很大差异

c.inBitmap:使用 inBitmap 属性可以告知 Bitmap 解码器去尝试使用已经存在的内存区域，新解码的Bitmap 会尝试去使用之前那张Bitmap 在Heap 中所占据的pixel

data 内存区域，而不是去问内存重新申请一块区域来存放 Bitmap。利用这种特性，

即使是上千张的图片，也只会仅仅只需要占用屏幕所能够显示的图片数量的内存大小， 但复用存在一些限制，具体体现在：在Android 4.4 之前只能重用相同大小的 Bitmap 的内存，而 Android 4.4 及以后版本则只要后来的 Bitmap 比之前的小即可。使用 inBitmap 参数前，每创建一个 Bitmap 对象都会分配一块内存供其使用，而使用了 inBitmap 参数后，多个 Bitmap 可以复用一块内存，这样可以提高性能

StringBuilder 替代 String: 在有些时候，代码中会需要使用到大量的字符串拼接的操作，这种时候有必要考虑使用 StringBuilder 来替代频繁的“+”

3.避免在类似 onDraw 这样的方法中创建对象，因为它会迅速占用大量内存，引起频繁的 GC 甚至内存抖动

4.减少内存泄漏也是一种避免 OOM 的方法



### 4.什么导致线程阻塞？线程如何关闭？

阻塞式方法是指程序会一直等待该方法完成期间不做其他事情，ServerSocket 的

accept()方法就是一直等待客户端连接。这里的阻塞是指调用结果返回之前，当前线程会被挂起，直到得到结果之后才会返回。此外，还有异步和非阻塞式方法在任务完成前就返回。

一种是调用它里面的 stop()方法

另一种就是你自己设置一个停止线程的标记 （推荐这种）



### 5.数据库的四大特征，数据库的隔离级别？

事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列， 这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。例如，银 行转账工作：从一个账号扣款并使另一个账号增款，这两个操作要么都执行，要 么都不执行。所以，应该把它们看成一个事务。事务是数据库维护数据一致性的 单位，在每个事务结束时，都能保持数据一致性。

事务具有以下 4 个基本特征：数据库的四大特征：

（1）原子性（Atomicity）

原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚。

（2）一致性（Consistency）

一个事务执行之前和执行之后都必须处于一致性状态。

（3）隔离性（Isolation）

 隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个 用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。

（4）持久性（Durability）

 持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性 的。

数据库的隔离级别：

1）Serializable(串行化)：可避免脏读、不可重复读、幻读的发生。

2）Repeatable read (可重复读)：可避免脏读、不可重复读的发生。

3）Read committed (读已提交)：可避免脏读的发生。

4）Read uncommitted (读未提交)：最低级别，任何情况都无法保证。



### 6.通过静态内部类实现单例模式有哪些优点？

1. 不用 synchronized ，节省时间。

2. 调用 getInstance() 的时候才会创建对象，不调用不创建，节省空间，这 有点像传说中的懒汉式。

   

### 7.Hashmap 底层为什么是线程不安全的？

并发场景下使用时容易出现死循环，在 HashMap 扩容的时候会调用 resize() 方法，就是这里的并发操作容易在一个桶上形成环形链表；这样 当获取一个不存在的 key 时，计算出的 index 正好是环形链表的下标就 会出现死循环；· 在 1.7 中 hash 冲突采用的头插法形成的链表，在并发条件下会形成循 环链表，一旦有查询落到了这个链表上，当获取不到值时就会死循环。



### 8.服务启动一般有几种，服务和 activty 之间怎么通信，服务和服务之间怎么通信

* 1、startService：onCreate()--->onStartCommand() ---> onDestory() 如果服务已经开启，不会重复的执行 onCreate()， 而是会调用 onStartCommand()。一旦服务开启跟调用者(开启者)就没有任何关系了。开启 者退出了，开启者挂了，服务还在后台长期的运行。开启者不能调用服务里面 的方法。

* 2、bindService：onCreate() --->onBind()--->onunbind()--->onDestory() bind 的方式开启服务，绑定服务，调用者挂了，服务也会跟着挂掉。绑定者可 以调用服务里面的方法。

* 3、通信：

  * 通过 Binder 对象。
  * 通过 broadcast(广播)。

  

### 9.Android消息机制模型吗？

消息机制主要包含：MessageQueue、Handler、Looper和Message这四大部分。



* Message：需要传递的消息，可以传递数据
* MessageQueue：消息队列，但是它的内部实现并不是用的队列，实际上是通过一个单链表的数据结构来维护消息列表，因为单链表在插入和删除上比较有优势。主要功能是向消息池传递消息（MessageQueue.enqueueMessage）和取走消息池的消息（MessageQueue.next）
* Handle：消息辅助类，主要功能是向消息池发送各种消息事件（Handler.sendMessage）和处理相应消息事件（Handler.handleMessage）
* Looper：不断循环执行（Looper.loop），从MessageQueue中读取消息，按分发机制将消息分发给目标处理者。



### 10.Service生命周期

```java
startService() --> onCreate() --> onStartCommand() --> Service running --> onDestory() 
bindService() --> onCreate() --> onBind() --> Service running --> onUnbind() --> onDestory()
```



**onCreate()：**
系统在Service第一次创建时执行此方法，来执行**只运行一次**的初始化工作，如果service已经运行，这个方法不会调用。

**onStartCommand()：**
每次客户端调用startService()方法启动该Service都会回调该方法(**多次调用**)，一旦这个方法执行，service就启动并且在后台长期运行，通过调用stopSelf()或stopService()来停止服务。

**onBind()：**
当组件调用bindService()想要绑定到service时，系统调用此方法(**一次调用**)，一旦绑定后，下次在调用bindService()不会回调该方法。在你的实现中，你必须提供一个返回一个IBinder来使客户端能够使用它与service通讯，你必须总是实现这个方法，但是如果你不允许绑定，那么你应返回null

**onUnbind()：**
当前组件调用unbindService()，想要解除与service的绑定时系统调用此方法(**一次调用**，一旦解除绑定后，下次再调用unbindService()会抛异常)

**onDestory()：**
系统在service不在被使用并且要销毁的时候调用此方法（**一次调用**）。service应在此方法中释放资源，比如线程，已注册的监听器、接收器等等。



### 11、什么是Dalvik虚拟机？

Dalvik是Google公司自己设计用于Android平台的Java虚拟机，它是Android平台的重要组成部分，支持dex格式的Java应用程序的运行。dex格式是专门为Dalvik设计的一种压缩格式，适合内存和处理器速度有限的系统。Google对其进行了特定的优化，Dalvik具有**高效、简洁、节省资源**的特点。从Android系统架构图知，Dalvik虚拟机运行在Android的运行时库层。



Dalvik作为面向Linux、为嵌入式操作系统设计的虚拟机，主要负责完成对象生命周期、堆栈管理、线程管理、安全和异常管理，以及垃圾回收等。另外，Dalvik早期并没有JIT编译器，直到Android2.2才加入了对JIT的技术支持。





### 12、ART虚拟机与Dalvik虚拟机的区别

* **什么是ART？**
  ART代表Android Runtime，其处理应用程序执行的方式完全不同于Dalvik，Dalvik是依靠一个Just-In-Time（JIT）编译器去解释字节码。开发者编译后的应用代码需要通过一个解释器在用户的设备上运行，这一机制并不高效，但让应用能更容易在不同硬件和架构上运行。ART则完全改变了这套做法，在应用安装时就预编译字节码到机器语言，这一机制叫Ahead-Of-Time（AOT）编译。在移除解释代码这一过程后，应用程序执行将更加效率。启动更快。

* **ART优点：**
  1. 系统性能的显著提升。
  2. 应用启动更快、运行更快、体验更流畅、触摸反馈更及时。
  3. 更长的电池续航能力
  4. 支持更低的硬件。

* **ART缺点：**
  1. 更大的存储空间占用，可能会增加10%-20%
  2.  更长的应用安装时间