### 1、Android 系统的启动流程

![image-20220913114818001](https://raw.githubusercontent.com/meiSThub/BlogImage/master/2022image-20220913114818001.png)

注意：

* App 进程：是由zygote 进程fork(孵化)出来的。
* SystemServer进程：管理系统服务的进程。

### 2、zygote进程启动流程

![image-20220913114850099](https://raw.githubusercontent.com/meiSThub/BlogImage/master/2022image-20220913114850099.png)

执行app_main.cpp 函数，进行AndroidRuntime（Android运行时）的初始化，设置zygote启动模式，定义参数，最后启动ZygoteInit。这里主要做了三件事：

1. 创建虚拟机
2. 注册JNI 方法
3. 进入Java世界，运行Java程序。

### 3、进程与虚拟机的关系

从zygote进程的启动流程可以知道，进程概念比较大，即进程包含虚拟机，虚拟机在进程启动的。

### 4、一个进程一个虚拟机，为什么要这样设计？

* （1）进程是资源分配的最小单位（内存私有）
* （2）虚拟机，解释运行Java字节码，并管理Java内存
* （3）沙盒机制，当前进程挂掉了，并不会影响其它进程的运行，起到了隔离的作用。

### 5、启动zygote服务的时候，为什么用Socket通信，而不用binder？

* （1）binder 在这个时候还没有初始化完成
* （2）binder是一个多线程机制，容易造成死锁

### 6、为什么要用Zygote进程去fork 应用进程？

* （1）init进程除了用于启动Zygote进程外，还会用于启动其它的系统进程，所以不适合用来启动应用进程
* （2）为什么不放在system_server进程中呢？因为system_server适用于启动和管理所有的系统服务的，这些系统服务都是公用的，不是App专属服务，存在一套就可以了。所以也不适合用于启动应用进程。

### 7、system_server进程启动流程

![image-20220913114935488](https://raw.githubusercontent.com/meiSThub/BlogImage/master/2022image-20220913114935488.png)

状态设置

![image-20220913114956602](https://raw.githubusercontent.com/meiSThub/BlogImage/master/2022image-20220913114956602.png)

### 8、SystemServiceManager 和 ServiceManager的区别？

* ServiceManager 用于管理所有的系统服务（增删改查）
* SystemServiceManager 用于管理所有的系统服务（SystemService）的生命周期的

### 9、ATMS和AMS服务的启动

在SystemServer进程启动执行main方法的时候，会调用 SystemServer 的 `startBootstrapServices()` 方法，在这个方法中，会启动 ATMS和AMS服务。

**启动ATMS服务：**

* （1）首先，调用`ActivityTaskManagerService#Lifecycle` 的startService方法，用反射的方式创建了`ActivityTaskManagerService#Lifecycle` 对象，在Lifecycle的构造函数中，创建了ATMS服务对象。

* （2）在ATMS的构造函数中，主要创建了一个`ClientLifecycleManager` 对象，用于管理和执行Activity的生命周期方法。在Activity的启动流程中，都会用到这个对象。

* （3）其次：调用`ActivityTaskManagerService#Lifecycle` 的onStart方法，这里主要做了两件事：

  1⃣️  把ATMS服务添加到ServiceManager中；

  2⃣️  调用ATMS的start方法，启动服务。

**启动AMS服务：**

* （1）创建AMS服务：与ATMS服务类似，也是先通过反射创建 `ActivityManagerService#Lifecycle` 对象，并执行onStart方法。

  在`ActivityManagerService#Lifecycle` 对象的构造函数中，创建了AMS对象。

* （2）AMS的构造函数中，会调用ATMS对象的 `initialize()` 方法，在这个方法中，就会创建`ActivityStackSupervisor` 对象，用于管理Activity的任务栈。 并设置当前任务栈：

  ![image-20220913115024683](https://raw.githubusercontent.com/meiSThub/BlogImage/master/2022image-20220913115024683.png)

* （3）AMS服务启动：在Lifecycle的onstart方法中，调用AMS的start方法，启动AMS服务。
* （4）管理AMS服务：在SystemServer的`startBootstrapServices` 方法的最后，调用AMS 的 `setSystemProcess` 方法，把AMS服务添加到ServiceManager中进行管理。

### 10、WMS服务的启动

在SystemServer的`startOtherServices` 方法中，会启动WMS服务，具体流程如下：

* （1）调用 `WindowManagerService` 的 main 方法，创建`WindowManagerService` 对象。
* （2）管理 `WindowManagerService` 服务，把WMS对象添加到ServiceManager中进行管理。
* （3）给AMS设置WMS对象：调用AMS的`setWindowManager`方法，设置WMS对象。