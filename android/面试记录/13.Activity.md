

### 1、Android 中的 Context, Activity，Appliction 有什么区别？

**相同：**Activity 和 Application 都是 Context 的子类。 

​		Context 从字面上理解就是上下文的意思，在实际应用中它也确实是起到了管理 上下文环境中各个参数和变量的总用，方便我们可以简单的访问到各种资源。 

**不同：**维护的生命周期不同。 Context 维护的是当前的 Activity 的生命周期， Application 维护的是整个项目的生命周期。 

使用 context 的时候，小心内存泄露，防止内存泄露，注意一下几个方面： 

1. 不要让生命周期长的对象引用 activity context，即保证引用 activity 的对象要与 activity 本身生命周期是一样的。 

2. 对于生命周期长的对象，可以使用 application，context。
3. 避免非静态的内部类，尽量使用静态类，避免生命周期问题，注意内部类对外部对象引用导致的生命周期变化。 



### 2、Context 是 什 么 ？ ， 一 个 应 用 有 多 少 个Context

1. 它描述的是一个应用程序环境的信息，即上下文。 
2. 该类是一个抽象(abstract class)类，Android 提供了该抽象类的具体实现类（ContextIml）。 
3. 通过它我们可以获取应用程序的资源和类，也包括一些应用级别操作， 例如：启动一个 Activity，发送广播，接受 Intent，信息，等。
4. 一个应用 Context 数量= Activity个数+service个数+1



### 3、Activity生命周期与启动模式（启动流程）

![image-20220913114203205](https://raw.githubusercontent.com/meiSThub/BlogImage/master/2022image-20220913114203205.png)

![image-20220913114219092](https://raw.githubusercontent.com/meiSThub/BlogImage/master/2022image-20220913114219092.png)

![image-20220913141553202](https://raw.githubusercontent.com/meiSThub/BlogImage/master/2022image-20220913141553202.png)

* （1）不管是Launcher启动App，还是App内启动Activity，最终都会调用到Activity的startActivity方法，进而调用startActivityForResult方法。
* （2）在startActivityForResult方法中，接着会调用Instrumentation的excuStartActivity方法，在这里会通过ServiceManager获取到ATMS的代理对象，调用它的startActivity方法，这是一个跨进程的通信，使得Activity的启动进去到ATMS进程中。
* （3）在ATMS中经过层层调用之后，最终会调用到`ActivityStackSupervisor`的`startSpecificActivity`方法，在这个方法中，会判断Activity所在的进程是否已经创建。
* （4）如果进程已经存在，就会调用`realStartActivityLocked`方法，继而调用`IApplicationThread`的`scheduleTransaction`方法，这又是一个跨进程通常，使得Activity的启动回到App进程。
* （5）如果进程不存在，AMS就会通过Socket发送一条创建App进程的消息到Zygote进程，通知Zygote进程fork出指定的App进程，并通过反射执行ActivityThread的main方法。
* （6）在ActivityThread的main方法中，又会通过ServiceManager获取到AMS的代理对象，并调用`attachApplication` 方法，把创建的`IApplicationThread` 对象传给AMS进行管理。
* （7）在**`attachApplication`**方法中，又会调用 `IApplicationThread` 的bindApplication方法，创建App的`Application`对象和执行`onCreate`方法。
* （8）最后，又会调用到`ActivityStackSupervisor`的`realStartActivityLocked`方法，启动MainActivity，后面的流程就跟普通Activity的启动一致了。
* (9) 调用 IApplicationThread 对象的 `scheduleTransaction` 方法，创建并执行Activity的生命周期方法。

### 4、setContentView的作用

setContentView的主要作用就是初始化 DecorView，并 通过 LayoutInflate 解析我们的xml布局文件，把创建的View添加到DecorView的ID 为content 的子View中。完成View的解析与创建。

### 5、Activity 如何与Window，View进行分工合作的？

在Activity的启动流程中，Activity对象在ActivityThread的handleLaunchActivity方法中创建，Activity对象创建之后，会执行Activity的attach方法，这里会创建PhoneWindow对象与Activity进行绑定，同时还会创建WindowManager对象，与Window对象进行绑定。

接着会执行Activity的生命周期方法onCreate()，这里就会执行我们的setContentView方法，setContentView方法只要就是初始化DecorView和解析xml布局文件，创建的DecorView会保存在PhoneWindow对象中。

在handleResumeActivity方法中，首先执行Activity的onResume()方法。接着会调用WindowManager的addView方法，把创建的DecorView添加到WindowManagerGlobal进行管理。同时会创建`ViewRootImpl` 对象，并调用ViewRootImpl的setView方法，让ViewRootImpl与DecorView进行绑定，同时把ViewRootImpl设置为DecorView的父类。

在ViewRootImpl的setView方法中，会执行requestLayout方法，完成View的第一帧绘制。

通过WindowSession进行IPC调用，将View添加到Window上，mWindow就是W类，用来接收WMS信息，同时使用inputChannel接收触摸事件回调。如下图：

![image-20220913114052211](https://raw.githubusercontent.com/meiSThub/BlogImage/master/2022image-20220913114052211.png)

Activity的生命周期，是用于管理View的。View的显示最终是由ViewRootImpl完成的。



### 6、在onResume 方法中，度量宽高有效吗？

不确定，需要看onResume在什么时候执行。

ViewRootImpl需要在执行了requestLayout()之后才会执行onResume方法；

而没用执行requestLayout()方法的话就不会调用WindowManager的updateViewLayout()方法，就不会继续执行ViewRootImpl中的setLayoutParams、scheduleTraversals、doTraversals以及Session的relayout、WMS中的relayoutWindow方法。没有这套流程的方法就不会有度量控件宽高的执行，因此onResume中获取不到宽高。

### 7、Activity栈关系

![image-20220913141642724](https://raw.githubusercontent.com/meiSThub/BlogImage/master/2022image-20220913141642724.png)

