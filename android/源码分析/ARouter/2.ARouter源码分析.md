[TOC]



注解处理器原理，可以参考：[Java基础/3.注解处理器](https://github.com/meiSThub/AtomProject/blob/master/Java%E5%9F%BA%E7%A1%80/3.%E6%B3%A8%E8%A7%A3%E5%A4%84%E7%90%86%E5%99%A8.md)

# 一、ARouter初始化

------

ARouter在使用的时候，都需要调用 ARouter的init方法，进行初始化，下面看一下初始化到底做了什么事件。

```java
public static void init(Application application) {
    if (!hasInit) {
        logger = _ARouter.logger;
        _ARouter.logger.info(Consts.TAG, "ARouter init start.");
        hasInit = _ARouter.init(application);// 这里调用 _ARouter.init 方法

        if (hasInit) {
            _ARouter.afterInit();
        }

        _ARouter.logger.info(Consts.TAG, "ARouter init over.");
    }
}
```

这里直接把请求转交给了 _ARouter 的 init 方法，这里使用了 **外观设计模式**。

_ARouter 的init 方法：

```java
protected static synchronized boolean init(Application application) {
    mContext = application;
    LogisticsCenter.init(mContext, executor);// 
    logger.info(Consts.TAG, "ARouter init success!");
    hasInit = true;
    mHandler = new Handler(Looper.getMainLooper());

    return true;
}
```

这里也是直接调用 LogisticsCenter 的 init 方法：

```java
public synchronized static void init(Context context, ThreadPoolExecutor tpe) throws HandlerException {
    mContext = context;
    executor = tpe;

    try {
        long startInit = System.currentTimeMillis();
        //billy.qi modified at 2017-12-06
        //load by plugin first
        loadRouterMap();// 这个方法就是给registerByPlugin属性赋值，registerByPlugin=false
        if (registerByPlugin) { // 如果是使用gradle插件装载类了，就不用在重复装载了
            logger.info(TAG, "Load router map by arouter-auto-register plugin.");
        } else {
            Set<String> routerMap;

            // It will rebuild router map every times when debuggable.
            if (ARouter.debuggable() || PackageUtils.isNewVersion(context)) {
                logger.info(TAG, "Run with debug mode or new install, rebuild router map.");
                // These class was generated by arouter-compiler.
                // 获取所有ARouter自动生成的类的类名 
                routerMap = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);
                if (!routerMap.isEmpty()) {
                    context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).edit().putStringSet(AROUTER_SP_KEY_MAP, routerMap).apply();
                }
								// 更新版本，如果版本没变，则下次进来不需要检索ARouter生成类的类名
                PackageUtils.updateVersion(context);    // Save new version name when router map update finishes.
            } else {
                logger.info(TAG, "Load router map from cache.");
                routerMap = new HashSet<>(context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).getStringSet(AROUTER_SP_KEY_MAP, new HashSet<String>()));
            }

            logger.info(TAG, "Find router map finished, map size = " + routerMap.size() + ", cost " + (System.currentTimeMillis() - startInit) + " ms.");
            startInit = System.currentTimeMillis();
						// 重点：遍历所有ARouter生成类的类名，这里是全类名，包含包名
            for (String className : routerMap) {
              // 如果是以 com.alibaba.android.arouter.routes.ARouter$$Root 开头的类
                if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_ROOT)) {
                    // This one of root elements, load root.
                  // 创建这个Root类的对象，并调用 loadInfo方法，并传入一个 Map 参数
                  // 即把所有的分组对象都保存到 Warehouse.groupsIndex 集合中
                    ((IRouteRoot) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.groupsIndex);
                } else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_INTERCEPTORS)) {
                  // 如果是以：com.alibaba.android.arouter.routes.ARouter$$Interceptors 开头的类，表示拦截器
                  // 创建该类对象，并装载所有的拦截器到 Warehouse.interceptorsIndex 这个Map集合中
                    // Load interceptorMeta
                    ((IInterceptorGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.interceptorsIndex);
                } else if (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_PROVIDERS)) {
                  // 如果是以：com.alibaba.android.arouter.routes.ARouter$$Providers 开头的类，表示IProvider
                  // 创建该类对象，并装载所有的IProvider类到 Warehouse.providersIndex 集合中
                    // Load providerIndex
                    ((IProviderGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.providersIndex);
                }
            }
        }

        logger.info(TAG, "Load root element finished, cost " + (System.currentTimeMillis() - startInit) + " ms.");

        if (Warehouse.groupsIndex.size() == 0) {
            logger.error(TAG, "No mapping files were found, check your configuration please!");
        }

        if (ARouter.debuggable()) {
            logger.debug(TAG, String.format(Locale.getDefault(), "LogisticsCenter has already been loaded, GroupIndex[%d], InterceptorIndex[%d], ProviderIndex[%d]", Warehouse.groupsIndex.size(), Warehouse.interceptorsIndex.size(), Warehouse.providersIndex.size()));
        }
    } catch (Exception e) {
        throw new HandlerException(TAG + "ARouter init logistics center exception! [" + e.getMessage() + "]");
    }
}
```

从上面的初始化代码中可以看出，初始化主要做了如下几件事：

* （1）**查找类名**：遍历所有的 class.dex文件，找出所有由ARouter创建的类，并保存在集合中，保存的类名是全类名，包含包名。

* （2）**装载分组类**：如果是以 com.alibaba.android.arouter.routes.ARouter$$Root开头，则调用这个类的 loadInto方法，装载所有的分组对象，如：

  ```java
  public class ARouter$$Root$$arouter implements IRouteRoot {
    @Override
    public void loadInto(Map<String, Class<? extends IRouteGroup>> routes) {
      routes.put("degrade", ARouter$$Group$$degrade.class);
      routes.put("full", ARouter$$Group$$full.class);
      routes.put("goods", ARouter$$Group$$goods.class);
      routes.put("service", ARouter$$Group$$service.class);
      routes.put("user", ARouter$$Group$$user.class);
    }
  }
  ```

  key：分组名称

  value：分组类类型

  参数就是：Warehouse.groupsIndex

  ```java
  class Warehouse {
      // Cache route and metas
      static Map<String, Class<? extends IRouteGroup>> groupsIndex = new HashMap<>();
  		.......    
  }
  ```

* **（3）装载拦截器**：如果是以：com.alibaba.android.arouter.routes.ARouter$$Interceptors 开头的类，表示拦截器，如：

  ```java
  public class ARouter$$Interceptors$$arouter implements IInterceptorGroup {
    @Override
    public void loadInto(Map<Integer, Class<? extends IInterceptor>> interceptors) {
      interceptors.put(8, TestInterceptor.class);
    }
  }
  ```

  Key: 是拦截器的优先级

  value：拦截器类

  参数：Warehouse.interceptorsIndex，定义如下：

  ```java
  class Warehouse {
      // Cache interceptor
      static Map<Integer, Class<? extends IInterceptor>> interceptorsIndex = new UniqueKeyTreeMap<>("More than one interceptors use same priority [%s]");
     .......    
  }
  ```

* **（4）装载IProvider对象**：如果是以：com.alibaba.android.arouter.routes.ARouter$$Providers 开头的类，表示IProvider对象，如：

  ```java
  public class ARouter$$Providers$$arouter implements IProviderGroup {
    @Override
    public void loadInto(Map<String, RouteMeta> providers) {
      providers.put("com.mei.arouter.submodule.GoodsService", RouteMeta.build(RouteType.PROVIDER, GoodsService.class, "/service/goods", "service", null, -1, -2147483648));
      providers.put("com.alibaba.android.arouter.facade.service.DegradeService", RouteMeta.build(RouteType.PROVIDER, DegradeServiceImpl.class, "/degrade/DegradeServiceImpl", "degrade", null, -1, -2147483648));
      providers.put("com.alibaba.android.arouter.facade.service.PathReplaceService", RouteMeta.build(RouteType.PROVIDER, MyPathReplaceService.class, "/degrade/myPathReplace", "degrade", null, -1, -2147483648));
    }
  }
  ```

  可以看到，这个装载方法里面，也是往参数的Map集合中，存入 RouteMeta 对象。但这里的key有不同：

  * 如果是普通的 IProvider 类，即直接继承IProvider的类，则 key 就是 类的全类名，这样的类**可以有多个**。

  * 如果是降级的 IProvider 类，即直接继承 DegradeService 的类，则 key 就是com.alibaba.android.arouter.facade.service.DegradeService，因此降级的类**至多只有有一个**。

  * 如果是路径替换的 IProvider 类，即直接继承 PathReplaceService 的类，则 key 就是：

    com.alibaba.android.arouter.facade.service.PathReplaceService，因此处理路径问题的 IProvider 类，**至多也只能有一个**。

关系如下图所示：

![image-20220602114924499](https://raw.githubusercontent.com/meiSThub/BlogImage/master/2022image-20220602114924499.png)

# 二、跳转

------

跳转分为两部分，

1. 构建Postcard对象
2. 跳转

根据路由跳转指定页面如下：

```java
public void go2SecondPage(View view) {
    ARouter.getInstance().build("/user/second").navigation();
}
```

## 1、构建Postcard

ARouter 的build方法：

```java
public Postcard build(String path) {
    return _ARouter.getInstance().build(path);
}
```

_ARouter 的 build 方法：

```java
protected Postcard build(String path) {
    if (TextUtils.isEmpty(path)) {// 如果路由为空，则直接报错
        throw new HandlerException(Consts.TAG + "Parameter is invalid!");
    } else {
        // 获取PathReplaceService对象，如果有的话
        PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);
        if (null != pService) {
            path = pService.forString(path);// 路由转换
        }
        return build(path, extractGroup(path));
    }
}
```

* 首先判断 path 是否为空，如果为空，则抛出 HandlerException 异常
* 获取PathReplaceService对象，如果不为空，则调用 forString 方法进行路由转换。
* extractGroup ：根据路由，获取分组名
* 调用 _ARouter 的 build 重载方法。

```java
protected Postcard build(String path, String group) {
  // 判断路由和分组不为空
    if (TextUtils.isEmpty(path) || TextUtils.isEmpty(group)) {
        throw new HandlerException(Consts.TAG + "Parameter is invalid!");
    } else {
        PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);
        if (null != pService) {
            path = pService.forString(path);
        }
      // 根据路由和分组名称，创建 Postcard 对象。
        return new Postcard(path, group);
    }
}
```

到此，Postcard 对象创建完成，此时 Postcard 对象中，仅有 **跳转路由** 和 **路由分组**。



### 获取 PathReplaceService 对象

PathReplaceService 对象本质是一个 IProvider 对象，在 初始化的时候，IProvider 相关的 类信息就已经被装载到了 ：

**static Map<String, RouteMeta> providersIndex = new HashMap<>();** 集合中。

在一个工程中，最多只会有一个实现 PathReplaceService 接口的类，即要么没有，要么就只会有一个。如果有的话，则在第一次调用 build 方法的时候，就会创建，并保存在 Warehouse 中的 providers 变量中：

```java
class Warehouse {
		......
    // Cache provider
    static Map<Class, IProvider> providers = new HashMap<>();
    static Map<String, RouteMeta> providersIndex = new HashMap<>();
  ......
}
```

获取 PathReplaceService 对象：

```java
ARouter.getInstance().navigation(PathReplaceService.class);
```

_ARouter 的 navigation 方法：

```java
protected <T> T navigation(Class<? extends T> service) {
    try {
      // 1. 创建跳卡对象
        Postcard postcard = LogisticsCenter.buildProvider(service.getName());

        // Compatible 1.0.5 compiler sdk.
        // Earlier versions did not use the fully qualified name to get the service
        if (null == postcard) {
            // No service, or this service in old version.
            postcard = LogisticsCenter.buildProvider(service.getSimpleName());
        }

        if (null == postcard) {
            return null;
        }
				// 2. 补充跳卡信息，如果是第一次则创建
        LogisticsCenter.completion(postcard);
      // 3. 返回 PathReplaceService 对象。
        return (T) postcard.getProvider();
    } catch (NoRouteFoundException ex) {
        logger.warning(Consts.TAG, ex.getMessage());
        return null;
    }
}
```

从上面代码可以看出，主要做了三件事：

1. **获取跳卡对象**：根据类名，从 providersIndex 集合中，获取 RouteMeta 对象。

   因为 navigation 方法，传递的是 PathReplaceService.class 对象，所以 serviceName 就是：**com.alibaba.android.arouter.facade.service.PathReplaceService**

   ```java
   public static Postcard buildProvider(String serviceName) {
       RouteMeta meta = Warehouse.providersIndex.get(serviceName);
   
       if (null == meta) {
           return null;
       } else {
           return new Postcard(meta.getPath(), meta.getGroup());
       }
   }
   ```

2. **补全 跳卡 的信息**：LogisticsCenter.completion(postcard);

   ```java
   public synchronized static void completion(Postcard postcard) {
       if (null == postcard) {
           throw new NoRouteFoundException(TAG + "No postcard!");
       }
   		// 1. 根据跳转路由，获取 RouteMeta 对象
       RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath());
       if (null == routeMeta) {    // Maybe its does't exist, or didn't load.
         // 该对象还没有被装载到内存
         	// 2. 根据路由分组，获取对应的分组对象
           Class<? extends IRouteGroup> groupMeta = Warehouse.groupsIndex.get(postcard.getGroup());  // Load route meta.
           if (null == groupMeta) {// 分组为空，则该路由不存在，报异常
               throw new NoRouteFoundException(TAG + "There is no route match the path [" + postcard.getPath() + "], in group [" + postcard.getGroup() + "]");
           } else {
               // Load route and cache it into memory, then delete from metas.
               try {
                  .... 
   								// 3. 创建 IRouteGroup 对象
                   IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();
                 // 把该分组的 RouteMeta 数据，全部装载到 Warehouse.routes 对象中
                   iGroupInstance.loadInto(Warehouse.routes);
                 // 移除分组，该分组的对象都已经保存到 Warehouse.routes 对象中了，可以删除
                   Warehouse.groupsIndex.remove(postcard.getGroup());
   								.... 
               } catch (Exception e) {
                   throw new HandlerException(TAG + "Fatal exception when loading group meta. [" + e.getMessage() + "]");
               }
   						// 重新调用一次 completion 方法，为了调用 routeMeta 不为空的逻辑，即把 RouteMeta 中的信息，都保存到 Postcard 对象中
               completion(postcard);   // Reload
           }
       } else {// routeMeta 不为空，把 RouteMeta 中的信息，都保存到 Postcard 对象中
         	
           postcard.setDestination(routeMeta.getDestination());// 目标类
           postcard.setType(routeMeta.getType());// 路由类型
           postcard.setPriority(routeMeta.getPriority());// 优先级
           postcard.setExtra(routeMeta.getExtra());// 参数
   
           Uri rawUri = postcard.getUri();// Uri对象
           if (null != rawUri) {   // Try to set params into bundle.
               Map<String, String> resultMap = TextUtils.splitQueryParameters(rawUri);
               Map<String, Integer> paramsType = routeMeta.getParamsType();
   
               if (MapUtils.isNotEmpty(paramsType)) {
                   // Set value by its type, just for params which annotation by @Param
                   for (Map.Entry<String, Integer> params : paramsType.entrySet()) {
                       setValue(postcard,
                               params.getValue(),
                               params.getKey(),
                               resultMap.get(params.getKey()));
                   }
   
                   // Save params name which need auto inject.
                   postcard.getExtras().putStringArray(ARouter.AUTO_INJECT, paramsType.keySet().toArray(new String[]{}));
               }
   
               // Save raw uri
               postcard.withString(ARouter.RAW_URI, rawUri.toString());
           }
   
           switch (routeMeta.getType()) {
               // 如果是 IProvider 类型
               case PROVIDER:  // if the route is provider, should find its instance
                   // Its provider, so it must implement IProvider
               		// 4. 创建 IProvider 对象
                   Class<? extends IProvider> providerMeta = (Class<? extends IProvider>) routeMeta.getDestination();
               		// 从 providers 集合中，获取IProvider 对象
                   IProvider instance = Warehouse.providers.get(providerMeta);
                   if (null == instance) { // There's no instance of this provider
                       IProvider provider;
                       try {
                         // 4. 创建 IProvider 对象
                           provider = providerMeta.getConstructor().newInstance();
                           provider.init(mContext);// 调用 IProvider 对象的init 方法
                         // 把创建的 IProvider 对象，保存到 providers 集合中
                           Warehouse.providers.put(providerMeta, provider);
                           instance = provider;
                       } catch (Exception e) {
                           throw new HandlerException("Init provider failed! " + e.getMessage());
                       }
                   }
                   postcard.setProvider(instance);
                   postcard.greenChannel();    // Provider should skip all of interceptors
                   break;
               case FRAGMENT:
                   postcard.greenChannel();    // Fragment needn't interceptors
               default:
                   break;
           }
       }
   }
   ```

   可以看到，这里会创建 IProvider 对象，并保存到 **Warehouse.providers** 集合中。

   这里不光创建 PathReplaceService 对象，而且还会把跟 PathReplaceService 对象在同一个分组的所有 IProvider 都保存到 providers 集合中。

3. 把创建 **PathReplaceService** 对象返回。

# 三、跳转

------

得到 Postcard 对象之后，要跳转到目标类信息就已经得到了，接着就 调用 Postcard 的 navigation 方法进行页面的跳转：

```java
public Object navigation(Context context) {
    return navigation(context, null);
}

public Object navigation(Context context, NavigationCallback callback) {
  	return ARouter.getInstance().navigation(context, this, -1, callback);
}
```

这里会调用到 ARouter 的 navigation 方法中，有四个参数：

```java
public Object navigation(Context mContext, Postcard postcard, int requestCode, NavigationCallback callback) {
    return _ARouter.getInstance().navigation(mContext, postcard, requestCode, callback);
}
```

_ARouter 的 navigation 方法：

```java
protected Object navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) {
    ....
    try {
      // 1. 补全跳卡信息，
      // 如果这个分组的数据，还没有保存到 Warehouse.routes 对象中，则会创建该分组的对象并把该分组所有 RouteMeta 对象保存到Warehouse.routes 对象中
        LogisticsCenter.completion(postcard);
    } catch (NoRouteFoundException ex) {
        logger.warning(Consts.TAG, ex.getMessage());
				.............

        if (null != callback) {// 没有匹配到路由
            callback.onLost(postcard);// 回调路由丢失方法
        } else {
            // No callback for this invoke, then we use the global degrade service.
          // 找不到路由对象，则创建降级处理服务的对象，如果有提供的话
            DegradeService degradeService = ARouter.getInstance().navigation(DegradeService.class);
            if (null != degradeService) {
                degradeService.onLost(context, postcard);
            }
        }

        return null;
    }

    if (null != callback) {
        callback.onFound(postcard);// 找到路由对象
    }
		
  	// 2.此次跳转，需要经过拦截器处理
    if (!postcard.isGreenChannel()) {   // It must be run in async thread, maybe interceptor cost too mush time made ANR.
      // 拦截器处理
        interceptorService.doInterceptions(postcard, new InterceptorCallback() {
            /**
             * Continue process
             *
             * @param postcard route meta
             */
            @Override
            public void onContinue(Postcard postcard) {
              // 3.拦截器处理完成，执行最终的跳转
                _navigation(context, postcard, requestCode, callback);
            }

            /**
             * Interrupt process, pipeline will be destory when this method called.
             *
             * @param exception Reson of interrupt.
             */
            @Override
            public void onInterrupt(Throwable exception) {
              // 中断，说明有异常
                if (null != callback) {
                    callback.onInterrupt(postcard);
                }
            }
        });
    } else {
      // 不需要执行拦截器
        return _navigation(context, postcard, requestCode, callback);
    }

    return null;
}
```

跳转逻辑中，做了三件事：

* （1）**补全 Postcard 跳卡信息**：这个过程中，如果该路由所在的分组还没有保存到 Warehouse.routes 对象中，则会创建该分组对象，并调用 loadInto 方法，把该分组的所有 RouteMeta 对象，保存到 Warehouse.routes 对象中。
* （2）**跳转经过拦截器处理：**除了 IProvider 和 Fragment 之外，其它跳转需要经过拦截器处理。所以提供的拦截器在这里发挥作用。
* （3）执行跳转：_navigation方法。



调用 _ARouter 的 _navigation 方法进行页面的跳转：

```java
private Object _navigation(final Context context, final Postcard postcard, final int requestCode, final NavigationCallback callback) {
    final Context currentContext = null == context ? mContext : context;
		// 路由类型
    switch (postcard.getType()) {	
        case ACTIVITY:// 如果是Activity，
            // Build intent
            final Intent intent = new Intent(currentContext, postcard.getDestination());// 获取Activity 类型
            intent.putExtras(postcard.getExtras());// 设置跳转参数

            // Set flags.
            int flags = postcard.getFlags();// 设置标签
            if (-1 != flags) {
                intent.setFlags(flags);
            } else if (!(currentContext instanceof Activity)) {    // Non activity, need less one flag.
                intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
            }

            // Set Actions
            String action = postcard.getAction();// 设置Action
            if (!TextUtils.isEmpty(action)) {
                intent.setAction(action);
            }

            // Navigation in main looper.
            runInMainThread(new Runnable() {
                @Override
                public void run() {
                  // 在主线程进行Activity 的跳转
                    startActivity(requestCode, currentContext, intent, postcard, callback);
                }
            });

            break;
        case PROVIDER:// 如果是IProvider 对象，则直接返回 IProvider 对象
            return postcard.getProvider();
        case BOARDCAST:// 广播
        case CONTENT_PROVIDER:// ContentProvider
        case FRAGMENT:// Fragment 
            Class fragmentMeta = postcard.getDestination();
            try {
              // 创建对象
                Object instance = fragmentMeta.getConstructor().newInstance();
                if (instance instanceof Fragment) {
                    ((Fragment) instance).setArguments(postcard.getExtras());
                } else if (instance instanceof android.support.v4.app.Fragment) {
                    ((android.support.v4.app.Fragment) instance).setArguments(postcard.getExtras());
                }

                return instance;// 返回 广播，ContentProvider 或者 Fragment 对象
            } catch (Exception ex) {
                logger.error(Consts.TAG, "Fetch fragment instance error, " + TextUtils.formatStackTrace(ex.getStackTrace()));
            }
        case METHOD:// Method，方法
        case SERVICE:// Service 
        default:
            return null; // 返回空
    }

    return null;
}
```

* 如果路由指向的是Activity，则直接进行页面跳转
* 如果是 广播，ContentProvider 或者 Fragment ，则直接返回对象
* 如果是 Method，Service 对象，则直接返回null。