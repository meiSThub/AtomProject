* 内存泄漏定位
* 内存抖动定位
* 使用轻量级数据结构
* HashMap源码分析
* Bitmap内存优化

[TOC]



# 一、内存泄漏定位

我们都知道，内存泄漏的根本原因就是：堆内存中的长生命周期的对象持有短生命周期对象的引用，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收。

 

内存泄漏会导致可用内存慢慢变少，让程序慢慢变卡。最终还会导致臭名昭著的oom 内存溢出。既然内存泄漏导致的问题如此严重，在开发中应该怎么排查内存泄漏问题呢？

* 观察法：

  在Android中我们执行一段代码，比如进入了一个新的页面(Activity)，这时候我们的内存使用肯定比在前一个页面大，而在界面finish返回后，如果内存没有回落，那么很有可能就是出现了内存泄漏。

  从内存监控工具中观察内存曲线，是否存在不断上升的趋势且不会在程序返回时明显回落。这种方式可以发现最基本，也是最明显的内存泄露问题，对用户价值最大，操作难度小，性价比极高。

* 内存分析工具：MAT

 

### 1、观察法：

​	当运行App之后，在AS的底部工具栏中有：Profiler，打开，选择需要观察的App进程，即可看到App的内存，CPU，网络等使用情况，这里我们选择：Memory，即内存。就可以观察到App内存的具体使用情况。

 ![image-20200728173858994](https://raw.githubusercontent.com/meiSThub/BlogImage/master/image-20200728173858994.png)



### 2、使用内存分析工具

#### 2-1、收集内存快照

Android Studio为我们提供了内存分析工具：Profile，点开之后，如下图所示：

![image-20200729113510105](https://cdn.jsdelivr.net/gh/meiSThub/BlogImage/image-20200729113510105.png)

双击上图的MEMORY区域，就可以进入内存分析模块，进去之后，操作App，进入推出页面，触发GC，等待一会Dump一份内存快照，Android Studio就会列出内存中对象的详细情况，如下图：

![image-20200729111016572](https://cdn.jsdelivr.net/gh/meiSThub/BlogImage/image-20200729111016572.png)

上图有很多的功能模块，下面详细介绍具体功能：

1. memory：功能模块，这里选择查看内存：memory
2. Force garbage collection：手动触发GC，回收内存
3. Dump  Java heap：保存一份内存快照
4. Record：记录一段时间内存，内存中对象的分配情况
5. App heap：选择堆内存空间，这里选择App的堆内存，还有：image heap，zygote heap等。
6. Arrange by class：排序类型。对dump后的内存中的类，进行排序，可选有：Arrange by class(安装类排序）,Arrange by package(包名排序)和Arrange by callstack(调用栈排序)
7. Activity/Fragment Leaks：过滤可能泄漏的Activity和Fragment，对Dump下来的内存，初步分析可能泄漏的Activity或者Fragment
8. Project Classes：工程的类泄漏过滤
9. Al locations：对象个数
10. Native Size：native对象占用内存大小
11. Shallow Size：对象占用的内存大小
12. Retained Size：对象本身和对象引用的所有对象一共占用的内存大小
13. 类对象



从上图可以看出，当我们勾选：Activity/Fragment Leaks或者Project Classes的时候，Android Studio就会为我们分析出可能泄漏的类，如果Allocations中对象的个数超过1个，就有可能发生内存泄漏，这就为我们缩小了内存泄漏的范围。



点击可能泄漏的类，Android Studio就会列出类的对象和对象的引用关系，如下图：

![image-20200729145610351](https://cdn.jsdelivr.net/gh/meiSThub/BlogImage/image-20200729145610351.png)



1. 点击MainActivity ，右边2处就会列出MainActivity的所有对象
2. 此时内存中存在的MainActivity对象，这里可以看出，一共有5个对象
3. 具体某一个对象的引用关系，把this$0一步一步的展开，如果是简单的内存泄漏，这里就可以直接看出MainActivity被谁引用着。



本例子中，类都是被混淆了的，看不出是具体是被哪个类引用着，此时我们就可以借助MAT工具，来分析更加详细的内存信息和引用链关系。



在使用Mat工具之前，我们需要把内存快照信息保存到文件当中，如下图：

![image-20200729151252828](https://cdn.jsdelivr.net/gh/meiSThub/BlogImage/image-20200729151252828.png)



1. 内存快照图标，当我们Dump一份内存快照时，在这里就会生成一个Heap Dump的条目，这里代表的就是我们保存的那一份内存快照。
2. 当鼠标移动到**Heap Dump**时，就会出现“**2**”这个图标，在这里就可以把这份内存快照信息导出并保存
3. 除了点击“**2**”处的图标导出内存快照信息外，还可以右键点击“**3**”处的区域，对应的菜单有：**Export**选项，点击就可以保存。



通过Android Studio，获取一份内存快照信息，步骤如下：

1. 进入Android Studio 的Profile 内存模块

2. 操作App ，进入退出要分析的页面，反复几次。

3. 点击GC图标，释放内存，这一步主要是把可以回收的内存回收到，避免为内存分析带来误导。内存泄漏的对象是不会被回收的。

   ![image-20200729152134689](https://cdn.jsdelivr.net/gh/meiSThub/BlogImage/image-20200729152134689.png)

4. 点击Dump  Java heap按钮，Dump一份内存快照信息。

   ![image-20200729152358268](https://cdn.jsdelivr.net/gh/meiSThub/BlogImage/image-20200729152358268.png)

5. 选中**Activity/Fragment Leaks**或者**Project Classes**，分析可能泄漏的类

   ![image-20200729152639222](https://cdn.jsdelivr.net/gh/meiSThub/BlogImage/image-20200729152639222.png)



6. 点击导出内存快照按钮，保存内存快照信息

   ![image-20200729152807534](https://cdn.jsdelivr.net/gh/meiSThub/BlogImage/image-20200729152807534.png)

保存内存快照信息到指定的目录：



![image-20200729152928984](https://cdn.jsdelivr.net/gh/meiSThub/BlogImage/image-20200729152928984.png)



1. 文件名
2. 文件保存的路径
3. 保存



#### 2-2、hprof文件转换

MAT 全称是：Memory Analyzer ，下载地址为：https://www.eclipse.org/mat/downloads.php。下载解压就可以用，绿色软件。



在2-1中，通过Android Studio已经获取了一份内存快照信息文件：**3.hprof**，但是这个文件的格式，与Mat要求的格式不太一样，所以这里需要先把**3.hprof**文件转换成Mat可以识别的格式。



**2-2-1、配置hprof-conv环境变量**



在Android SDK中的platform-tools中，有一个**hprof-conv**命令，就可以把Android Studio生成的hprof文件，转换成Mat可以识别的hprof文件。

要想使用hprof-conv命令，需要先配置环境变量，把该命令加入到系统命令库中去。mac配置如下：

在命令行终端中，输入：

> vim ~/.bash_profile

编辑该文件，加入如下代码，后面的路径就是你本地的Android SDK 的platform-tools文件夹路径

>  export PATH="$PATH:/Users/mei/Library/Android/sdk/platform-tools" 



最后执行source命令，使配置生效：

> source  ~/.bash_profile



**2-2-2、hprof文件转换：**



配置好环境变量之后，就可以直接在命令行中使用：**hprof-conv**命令了。



下面就通过命令，把Android Studio生成的hprof文件，转换成Mat可以识别的hprof文件，命令如下：

> hprof-conv -z 3.hprof 3-transf.hprof

参数说明:

* -z 表示排除非App的堆内存信息，如Zygote内存信息
* 3.hprof ：通过Android Studio生成的hprof文件，如果命令行没有切换到该文件目录下，则需要使用绝对路径。
* 3-transf.hprof：转换后的文件，默认保存到命令行当前落在地目录下，可以通过绝对路径指定保存位置。



通过这条命令，就把Android Studio 生成的hprof转换成了mat可以识别的hprof文件。



#### 2-3、Mat分析内存

打开Mat工具，在菜单栏中，选择file->Open File ，选择要刚才转换生成的**3-transf.hprof**文件。



在MAT窗口上，OverView是一个总体概览，显示总体的内存消耗情况和疑似问题。MAT提供了多种分析维度，其中Histogram、Dominator Tree、Top Consumers和Leak Suspects的分析维度是不同的。下面分别介绍下它们，如下所示：

![image-20200729171132000](https://cdn.jsdelivr.net/gh/meiSThub/BlogImage/image-20200729171132000.png)



功能介绍：

1. Overivew： 总体概览
2. Histogram：列出内存中的**所有实例类型对象和其个数以及大小**，并在顶部的**regex**区域支持正则表达式查找。更加适合较为复杂的内存泄漏分析。
3. Dominator Tree：列出最大的对象及其依赖存活的**Object**。相比Histogram，能更方便地看出引用关系。
4. Top Consumers：通过**图像列出最大的Object**。
5. Leak Suspects：通过MAT自动分析内存泄漏的原因和泄漏的一份总体报告。
6. Top Componects：



分析内存最常用的是Histogram和Dominator Tree这两个视图，点击Histogram进入直方图视图，一共有四列：

![image-20200729190347468](https://cdn.jsdelivr.net/gh/meiSThub/BlogImage/image-20200729190347468.png)

1. ClassName：类名
2. Objects：对象实例个数
3. Shallow Heap：对象自身占用的内存大小，**不包括它引用的对象**。非数组的常规对象的Shallow Heap Size由其成员变量的数量和类型决定，数组的Shallow Heap Size由数组元素的类型（对象类型、基本类型）和数组长度决定。真正的内存都在堆上，看起来是一堆原生的byte[]、char[]、int[]，对象本身的内存都很小。因此Shallow Heap**对分析内存泄漏意义不是很大**。
4. Retained Heap：是**当前对象大小与当前对象可直接或间接引用到的对象的大小总和**，包括被递归释放的。即：Retained Size就是当前对象被GC后，从Heap上总共能释放掉的内存大小。
5. Regex：按照给定的名称过滤类



这里的类信息有很多，不好查找，这时候就可以结合Android Studio给我们提示的泄漏对象，来过滤，缩小查找的范围。如：MainActivity。

![image-20200730160354756](https://cdn.jsdelivr.net/gh/meiSThub/BlogImage//image-20200730160354756.png)



根据MainActivity过滤之后，可以看到，在触发GC之后的内存中，MainActivity的对象还有4个，这肯定就是发生了内存的泄漏。那如何查找MainActivity是如何泄漏的呢？

这里右键点击MainActivity，选择菜单：Merge Shortest Paths to GC Roots->exclude all phantom/weak/soft etc. references。如下图：

![image-20200730160925988](https://cdn.jsdelivr.net/gh/meiSThub/BlogImage/image-20200730160925988.png)

1. 右键点击MainActivity
2. Merge Shortest Paths to GC Roots：生成该对象到GC Roots最短路径
3. exclude all phantom/weak/soft etc. references：排除虚引用、弱引用和软引用，即只看强引用。

这里排出软弱虚等引用，避免对内存泄漏的分析带来影响。确定之后，Mat就会为我们生成GC Root的引用链关系图，通过这个就可以分析出是哪个对象引用着MainActivity，造成MainActivity无法释放，导致的内存泄漏。



生成的GC Root 引用链关系图如下：

![image-20200730163858672](https://cdn.jsdelivr.net/gh/meiSThub/BlogImage/image-20200730163858672.png)



把生成的引用链一步一步展开，如上图所示。现在就来分析一下引用链关系图：

1. this$0 : MainActivity的对象
2. ArrayList：MainActivity的对象被**ArrayList**内的**array**数组引用着。
3. ConcurrentHashMap$Node：从这里可以看出，ArrayList的对象又被ConcurrentHashMap的Node节点引用着。
4. ConcurrentHashMap：HashMap中有一个table数组，引用着Node节点。
5. com.netease.nimlib.g.e：从第五点可以看出，ConcurrentHashMap的对象a被 类：com.netease.nimlib.g.e的对象引用着
6. com.netease.nimlib.g.a：**com.netease.nimlib.g.e**类的对象b被类：**com.netease.nimlib.g.a**的对象**e**引用着
7. com.netease.nimlib.g.a：类中有一个成员变量：**e**，引用着**com.netease.nimlib.g.e**的对象**b**。

通过上面的分析，最终定位到类**com.netease.nimlib.g.a**中的成员变量**e**，打开源码看可以发现，**e**是一个静态变量，保存了所有的观察者对象，观察者又持有MainActivity的引用，所以导致了MainActivity的泄漏。变量 **e**中保存了所有注册过的观察者，开发者在注册观察者的时候，没有在onDestory方法中解注册，所以导致了MainActivity的内存泄漏。知道原因后，把所有的观察者在onDestory（）方法中解注册之后，发现MainActivity就没有泄漏了。



**通过Mat查找内存泄漏步骤**：

1. 打开符合Mat格式的hprof文件
2. 在概览页面，打开直方图：Histogram
3. 根据Android Studio提示的泄漏信息，过滤对象信息
4. 右键选中可能泄漏的类，选择**Merge Shortest Paths to GC Roots**，生成对象到GC Root的最短路径，即GC Root引用链
5. 展开引用链，分析对象被谁引用着，导致无法释放，并解决内存泄漏。



通过上面的方法，一步步分析，就可以找到内存泄漏的原因，至此，内存泄漏的定位和解决方法就讲完了。



# 二、内存抖动



