[TOC]



# 一、ActivityLifecycleCallbacks使用

当希望全局监听Activity的生命周期，做一些全局操作的时候，可以在Application中通过**registerActivityLifecycleCallbacks**()方法，注册**ActivityLifecycleCallbacks**回调。这样就可以全局监听Activity的生命周期了。

**ActivityLifecycleCallbacks** 是**Application**中声明的一个内部接口，定义如下：

```java
public interface ActivityLifecycleCallbacks {
      void onActivityCreated(Activity activity, Bundle savedInstanceState);
      void onActivityStarted(Activity activity);
      void onActivityResumed(Activity activity);
      void onActivityPaused(Activity activity);
      void onActivityStopped(Activity activity);
      void onActivitySaveInstanceState(Activity activity, Bundle outState);
      void onActivityDestroyed(Activity activity);
}
```



在Application中：

```java
registerActivityLifecycleCallbacks(new ActivityLifecycleCallbacks() {

    @Override
    public void onActivityStopped(Activity activity) {
        Log.v("MyApplication", "onActivityStopped");
    }

    @Override
    public void onActivityStarted(Activity activity) {
        Log.v("MyApplication", "onActivityStarted");
    }

    @Override
    public void onActivitySaveInstanceState(Activity activity, Bundle outState) {
        Log.v("MyApplication", "onActivitySaveInstanceState");
    }

    @Override
    public void onActivityResumed(Activity activity) {
        Log.v("MyApplication", "onActivityResumed");
    }

    @Override
    public void onActivityPaused(Activity activity) {
        Log.v("MyApplication", "onActivityPaused");
    }

    @Override
    public void onActivityDestroyed(Activity activity) {
        Log.v("MyApplication", "onActivityDestroyed");
    }

    @Override
    public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
        Log.v("MyApplication", "onActivityCreated");
    }
});
```

打印日志如下：

>2020-08-25 20:36:44.553 28323-28323/? V/MyApplication: onActivityPaused
>2020-08-25 20:36:44.589 28323-28323/? V/MyApplication: onActivityCreated
>2020-08-25 20:36:44.645 28323-28323/? V/MyApplication: onActivityStarted
>2020-08-25 20:36:44.649 28323-28323/? V/MyApplication: onActivityResumed
>2020-08-25 20:36:45.076 28323-28323/? V/MyApplication: onActivityStopped
>2020-08-25 20:36:45.079 28323-28323/? V/MyApplication: onActivitySaveInstanceState
>2020-08-25 20:36:47.485 28323-28323/? V/MyApplication: onActivityPaused
>2020-08-25 20:36:47.503 28323-28323/? V/MyApplication: onActivityStarted
>2020-08-25 20:36:47.506 28323-28323/? V/MyApplication: onActivityResumed
>2020-08-25 20:36:47.895 28323-28323/? V/MyApplication: onActivityStopped
>2020-08-25 20:36:47.898 28323-28323/? V/MyApplication: onActivityDestroyed



下面就看看源码，看看注册的这个回调是在什么时机调用的。Application的**registerActivityLifecycleCallbacks**（）方法：

```java
public void registerActivityLifecycleCallbacks(ActivityLifecycleCallbacks callback) {
    synchronized (mActivityLifecycleCallbacks) {
        mActivityLifecycleCallbacks.add(callback);
    }
}
```

这里把**ActivityLifecycleCallbacks**回调放到了一个集合当中。



既然是分析**Activity**的生命周期，那么就进入**Activity**的源码看看生命周期方法，有没有回调我们注册的监听。**Activity**的**onCreate**源码如下：



```java
protected void onCreate(@Nullable Bundle savedInstanceState) {
    if (DEBUG_LIFECYCLE) Slog.v(TAG, "onCreate " + this + ": " + savedInstanceState);

   	..............................................
    mFragments.dispatchCreate();
    dispatchActivityCreated(savedInstanceState);
    if (mVoiceInteractor != null) {
        mVoiceInteractor.attachActivity(this);
    }
    mRestoredFromBundle = savedInstanceState != null;
    mCalled = true;

}
```

**Activity**的**onCreate**方法，又执行了**dispatchActivityCreated**方法：

```java
private void dispatchActivityCreated(@Nullable Bundle savedInstanceState) {
  // 获取Application对象，执行dispatchActivityCreated方法
    getApplication().dispatchActivityCreated(this, savedInstanceState);
    Object[] callbacks = collectActivityLifecycleCallbacks();
    if (callbacks != null) {
        for (int i = 0; i < callbacks.length; i++) {
            ((Application.ActivityLifecycleCallbacks) callbacks[i]).onActivityCreated(this,
                    savedInstanceState);
        }
    }
}
```

在这个方法中可以看出，在**dispatchActivityCreated**方法中，**Activity**调用了**Application**的**dispatchActivityCreated**方法：



```java
void dispatchActivityCreated(@NonNull Activity activity,
        @Nullable Bundle savedInstanceState) {
    Object[] callbacks = collectActivityLifecycleCallbacks();// 获取所有注册的ActivityLifecycleCallbacks
    if (callbacks != null) {
        for (int i=0; i<callbacks.length; i++) {
            ((ActivityLifecycleCallbacks)callbacks[i]).onActivityCreated(activity,
                    savedInstanceState);// 回调onActivityCreated方法
        }
    }
}

private Object[] collectActivityLifecycleCallbacks() {
    Object[] callbacks = null;
    synchronized (mActivityLifecycleCallbacks) {
      if (mActivityLifecycleCallbacks.size() > 0) {
        callbacks = mActivityLifecycleCallbacks.toArray();
      }
    }
    return callbacks;
}
```



从这里看出，最终就会回调到注册的**ActivityLifecycleCallbacks**的**onActivityCreated**方法。



其它生命周期的方法回调与onCreate方法类似，这里就不一一分析了。



# 二、LeakCanary使用：

在module的build.gradle文件中配置：

```groovy
dependencies {   
  debugCompile 'com.squareup.leakcanary:leakcanary-android:1.5.2'   
  releaseCompile 'com.squareup.leakcanary:leakcanary-android-no-op:1.5.2' 
}
```

接下来在Application加入如下代码：

```java
public class LeakApplication extends Application {
    @Override public void onCreate() {
    super.onCreate();
    if (LeakCanary.isInAnalyzerProcess(this)) {//1
      // This process is dedicated to LeakCanary for heap analysis.
      // You should not init your app in this process.
      return;
    }
    LeakCanary.install(this);
  }
}
```

注释1处的代码用来进行过滤操作，如果当前的进程是用来给LeakCanary 进行堆分析的则return，否则会执行LeakCanary的install方法。这样我们就可以使用LeakCanary了，如果检测到某个Activity 有内存泄露，LeakCanary 就会给出提示。



从以代码可以了解到，核心代码就是LeakCanary.install(this)这行代码，接下来，就从这里出发将LeakCanary一步一步进行拆解。



# 三、LeakCanary源码分析：



## 3-1、LeakCanary#install()

```java
public static @NonNull RefWatcher install(@NonNull Application application) {
  return refWatcher(application).listenerServiceClass(DisplayLeakService.class)
      .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())
      .buildAndInstall();
}
```



在install()方法中的处理，可以分解为如下四步：

* 1、refWatcher(application)

* 2、链式调用listenerServiceClass(DisplayLeakService.class)

* 3、链式调用excludedRefs(AndroidExcludedRefs.createAppDefaults().build())

* 4、链式调用uildAndInstall()

  

### 3-1-1、第一步，调用LeakCanary的**refWatcher**方法：

```java
public static @NonNull AndroidRefWatcherBuilder refWatcher(@NonNull Context context) {
  return new AndroidRefWatcherBuilder(context);
}

// AndroidRefWatcherBuilder 类
public final class AndroidRefWatcherBuilder extends RefWatcherBuilder<AndroidRefWatcherBuilder> {

  private final Context context;

  AndroidRefWatcherBuilder(@NonNull Context context) {
    this.context = context.getApplicationContext();
  }
}

// RefWatcherBuilder 
public class RefWatcherBuilder<T extends RefWatcherBuilder<T>> {

  private final HeapDump.Builder heapDumpBuilder;

  public RefWatcherBuilder() {
    // 新建了一个HeapDump的构造器对象，其中HeapDump就是一个保存heap dump信息的数据结构。
    heapDumpBuilder = new HeapDump.Builder();
  }
}
```

这个方法很简单，就是创建了一个AndroidRefWatcherBuilder对象，并保存Application类型的Context。



AndroidRefWatcherBuilder是一个适配Android平台的引用观察者构造器对象，它继承了RefWatcherBuilder，RefWatcherBuilder是一个负责建立引用观察者**RefWatcher实例**的基类构造器，在其默认的构造方法中，新建了一个HeapDump的构造器对象，其中HeapDump就是一个保存heap dump信息的数据结构。



在new AndroidRefWatcherBuilder对象的时候，做了两件事：

* (1)、保存Application类型的Context
* (2)、创建HeapDump.Builder对象。



### 3-1-2、AndroidRefWatcherBuilder的listenerServiceClass方法：

```java
public @NonNull AndroidRefWatcherBuilder listenerServiceClass(
    @NonNull Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
  enableDisplayLeakActivity = DisplayLeakService.class.isAssignableFrom(listenerServiceClass);
  return heapDumpListener(new ServiceHeapDumpListener(context, listenerServiceClass));
}

 /** @see HeapDump.Listener */
public final T heapDumpListener(HeapDump.Listener heapDumpListener) {
  this.heapDumpListener = heapDumpListener;
  return self();
}

// ServiceHeapDumpListener 类
public final class ServiceHeapDumpListener implements HeapDump.Listener {

  private final Context context;
  private final Class<? extends AbstractAnalysisResultService> listenerServiceClass;

  public ServiceHeapDumpListener(@NonNull final Context context,
      @NonNull final Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
    this.listenerServiceClass = checkNotNull(listenerServiceClass,"listenerServiceClass");
    this.context = checkNotNull(context, "context").getApplicationContext();
  }

}
```

从上面代码可以看出，listenerServiceClass方法主要是保存了一个ServiceHeapDumpListener对象，ServiceHeapDumpListener里面存储着DisplayLeakService的Class对象和application对象。



DisplayLeakService：显示通知。



### 3-1-3、链式调用excludedRefs(AndroidExcludedRefs.createAppDefaults().build())

```java
// AndroidRefWatcherBuilder的excludedRefs方法
public final T excludedRefs(ExcludedRefs excludedRefs) {
  heapDumpBuilder.excludedRefs(excludedRefs); // 保存ExcludedRefs对象到HeapDump.Builder对象中
  return self();
}
```

下面看看AndroidExcludedRefs.createAppDefaults()方法：

```java
 public static @NonNull ExcludedRefs.Builder createAppDefaults() {
    return createBuilder(EnumSet.allOf(AndroidExcludedRefs.class));
  }

  public static @NonNull ExcludedRefs.Builder createBuilder(EnumSet<AndroidExcludedRefs> refs) {
    ExcludedRefs.Builder excluded = ExcludedRefs.builder();
    for (AndroidExcludedRefs ref : refs) {
      if (ref.applies) {
        ref.add(excluded);
        ((ExcludedRefs.BuilderWithParams) excluded).named(ref.name());
      }
    }
    return excluded;
  }
```

AndroidExcludedRefs这个类，它是一个enum类，它声明了Android SDK和厂商定制的SDK中存在的内存泄露的案例，这些内存泄漏的情况都会被Leakcanary的监测过滤掉。



目前这个版本是有46种这样的case被包含在内，后续可能会一直增加。然后EnumSet.allOf(AndroidExcludedRefs.class)这个方法将会返回一个包含AndroidExcludedRefs元素类型的EnumSet。Enum是一个抽象类，在这里具体的实现类是通用正规型的RegularEnumSet，如果Enum里面的元素个数大于64，则会使用存储大数据量的JumboEnumSet。最后，在createBuilder这个方法里面构建了一个排除引用的建造器excluded，将各式各样的case分门别类地保存起来再返回出去。



### 3-1-4、链式调用AndroidRefWatcherBuilder#uildAndInstall()

```java
private boolean watchActivities = true;

public @NonNull RefWatcher buildAndInstall() {
  // 1.判断LeakCanaryInternals.installedRefWatcher是否已经被赋值，如果被赋值了，则会抛出异常，警告buildAndInstall()这个方法应该仅仅只调用一次
  if (LeakCanaryInternals.installedRefWatcher != null) {
    throw new UnsupportedOperationException("buildAndInstall() should only be called once.");
  }
  RefWatcher refWatcher = build();// 2. 构建引用观察者RefWatcher对象
  if (refWatcher != DISABLED) {
    if (enableDisplayLeakActivity) {
      LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, true);
    }
    if (watchActivities) {// 3. watchActivities默认为true
      ActivityRefWatcher.install(context, refWatcher);// 监听Activity
    }
    if (watchFragments) {// 4. 观察Fragment
      FragmentRefWatcher.Helper.install(context, refWatcher);
    }
  }
  // 5.为LeakCanaryInternals.installedRefWatcher赋值
  LeakCanaryInternals.installedRefWatcher = refWatcher;
  return refWatcher;
```

从上面代码可以看出，buildAndInstall方法主要做了如下几件事：

*  (1)、检测LeakCanaryInternals.installedRefWatcher是否已经被赋值，如果被赋值了，则会抛出异常，警告buildAndInstall()这个方法应该仅仅只调用一次
* (2)、根据前面三步提供的配置对象，构建一个**RefWatcher**对象。
* (3)、观察Activity是否泄漏
* (4)、观察Fragment是否泄漏
* (5)、为LeakCanaryInternals.installedRefWatcher赋值

这里再去看看注释2处的build()方法具体做了什么操作：

```java
public final RefWatcher build() {
  // 1. 是否监听泄漏
  if (isDisabled()) {
    return RefWatcher.DISABLED;
  }

  // 2. 可以被忽略的内存泄漏
  if (heapDumpBuilder.excludedRefs == null) {
    heapDumpBuilder.excludedRefs(defaultExcludedRefs());
  }

  // 3. 转储堆信息到hprof文件，并在解析完 hprof 文件后进行回调，最后通知 DisplayLeakService 弹出泄漏提醒。
  HeapDump.Listener heapDumpListener = this.heapDumpListener;
  if (heapDumpListener == null) {
    heapDumpListener = defaultHeapDumpListener();
  }

  // 4. 判断是否处于调试模式，调试模式中不会进行内存泄漏检测。为什么呢？因为在调试过程中可能会保留上一个引用从而导致错误信息上报。
  DebuggerControl debuggerControl = this.debuggerControl;
  if (debuggerControl == null) {
    debuggerControl = defaultDebuggerControl();
  }

  // 5. 堆信息转存者，dump 内存泄漏处的 heap 信息到 hprof 文件
  HeapDumper heapDumper = this.heapDumper;
  if (heapDumper == null) {
    heapDumper = defaultHeapDumper();
  }

  // 6. 线程控制器，在 onDestroy() 之后并且主线程空闲时执行内存泄漏检测
  WatchExecutor watchExecutor = this.watchExecutor;
  if (watchExecutor == null) {
    watchExecutor = defaultWatchExecutor();
  }

  // 7. 用于 GC，watchExecutor 首次检测到可能的内存泄漏，会主动进行 GC，GC 之后会再检测一次，仍然泄漏的判定为内存泄漏，最后根据heapDump信息生成相应的泄漏引用链。
  GcTrigger gcTrigger = this.gcTrigger;
  if (gcTrigger == null) {
    gcTrigger = defaultGcTrigger();
  }

  // 8. 用于要进行可达性检测的类列表
  if (heapDumpBuilder.reachabilityInspectorClasses == null) {
    heapDumpBuilder.reachabilityInspectorClasses(defaultReachabilityInspectorClasses());
  }

  // 9.创建RefWatcher对象
  return new RefWatcher(watchExecutor, debuggerControl, gcTrigger, heapDumper, heapDumpListener,
      heapDumpBuilder);
}
```

从上面代码可以看出，build方法主要是根据配置的信息，构建一个RefWatcher对象。主要信息有：

* (1)、excludedRefs：记录可以被忽略的泄漏路径，这个在链式调用第三步的excludedRefs(AndroidExcludedRefs.createAppDefaults().build())方法中提供了。
* (2)、heapDumpListener：保存内存信息到hprof文件后的回调接口，这个在链式调用的**listenerServiceClass方法**中提供了。
* (3)、heapDumper：dump 内存信息并保存到 hprof 文件，在链式调用的第一步创建**AndroidRefWatcherBuilder**对象的时候，在**RefWatcherBuilder**的默认构造函数中有创建。
* (4)、watchExecutor：创建一个默认的线程池，AndroidWatchExecutor对象。
* (5)、gcTrigger：执行GC的对象

最后，根据这些对象，创建一个新的RefWatcher并将其返回。



这里主要是根据前面三步提供的配置对象，构建一个引用观察者：**RefWatcher**对象。通过这个对象，去观察对象是否泄漏。接下来看看**ActivityRefWatcher#install**方法的操作：

```java
public static void install(@NonNull Context context, @NonNull RefWatcher refWatcher) {
    Application application = (Application) context.getApplicationContext();
  // 1.创建ActivityRefWatcher对象
    ActivityRefWatcher activityRefWatcher = new ActivityRefWatcher(application, refWatcher);
		// 2. 为Application注册Activity生命周期监听回调
    application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks);
  }

// 3. 创建一个Application.ActivityLifecycleCallbacks对象
 private final Application.ActivityLifecycleCallbacks lifecycleCallbacks =
      new ActivityLifecycleCallbacksAdapter() {
        @Override public void onActivityDestroyed(Activity activity) {
          // 4.把Activity对象交给RefWatcher进行监控
          refWatcher.watch(activity);// refWatcher是ActivityRefWatcher对象
        }
      };
```

从上面代码可以看出，**ActivityRefWatcher**的静态方法：**install()**主要做了两件事：

* 创建一个**ActivityRefWatcher**对象
* 为**Application**对象注册一个**Activity**生命周期监听的回调。

在这个Activity生命周期的回调中，监听了Activity的onDestory方法，并在onActivityDestroyed方法中，把Activity对象交给ActivityRefWatcher对象监管。

## 3-2、ActivityRefWatcher#watch()方法

ActivityRefWatcher类是继承与RefWatcher类的，在ActivityRefWatcher类中，没有实现watch()方法，在其父类RefWatcher中有具体的实现，RefWatcher类中的watch()方法：

```java
public void watch(Object watchedReference) {
  watch(watchedReference, "");
}

/**
 * Watches the provided references and checks if it can be GCed. This method is non blocking,
 * the check is done on the {@link WatchExecutor} this {@link RefWatcher} has been constructed
 * with.
 *
 * @param referenceName An logical identifier for the watched object.
 */
public void watch(Object watchedReference, String referenceName) {
  if (this == DISABLED) {
    return;
  }
  checkNotNull(watchedReference, "watchedReference");
  checkNotNull(referenceName, "referenceName");
  final long watchStartNanoTime = System.nanoTime();
  String key = UUID.randomUUID().toString();// 1. 生成一个唯一的Key
  retainedKeys.add(key);// 2.把生成的key保存在Set集合中
  // 3. 用一个弱引用：KeyedWeakReference包裹监听对象（如：Activity），弱引用关联一个引用队列：queue
  final KeyedWeakReference reference =
      new KeyedWeakReference(watchedReference, key, referenceName, queue);
	// 4. 创建一个字任务，分析是否有内存泄漏
  ensureGoneAsync(watchStartNanoTime, reference);
}
```

RefWatcher的watch方法逻辑很简单，主要做了4件事：

* （1）、为监听对象生成一个唯一的key值

* （2）、保存key值到一个CopyOnWriteArraySet集合中

* （3）、创建一个KeyedWeakReference类型的弱引用，包裹Activity对象，并与一个引用队列进行关联

* （4）、创建一个字任务，分析是否有内存泄漏

  

这里我们在看一下自定义的弱引用：KeyedWeakReference类：

```java
// KeyedWeakReference类
final class KeyedWeakReference extends WeakReference<Object> {
  public final String key;// 保存对象的key值
  public final String name;// 保存名称

  KeyedWeakReference(Object referent, String key, String name,
      ReferenceQueue<Object> referenceQueue) {
    // 1
    super(checkNotNull(referent, "referent"), checkNotNull(referenceQueue, "referenceQueue"));
    this.key = checkNotNull(key, "key");
    this.name = checkNotNull(name, "name");
  }
}
```

可以看到，在KeyedWeakReference内部，使用了key和name标识了一个被检测的WeakReference对象。在注释1处，将弱引用和引用队列 ReferenceQueue 关联起来，如果弱引用referent持有的对象被GC回收，JVM就会把这个弱引用加入到与之关联的引用队列referenceQueue中。即 KeyedWeakReference 持有的 Activity 对象如果被GC回收，该弱引用对象就会加入到引用队列 referenceQueue 中。



## 3-3、RefWatcher#的ensureGoneAsync方法

```java
private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) {
  watchExecutor.execute(new Retryable() {
    @Override public Retryable.Result run() {
      return ensureGone(reference, watchStartNanoTime);
    }
  });
}
```

在这个方法中，调用了watchExecutor对象的execute方法，执行了一个异步任务。watchExecutor对象是AndroidWatchExecutor类型。



## 3-4、AndroidWatchExecutor的execute方法：



```java
public final class AndroidWatchExecutor implements WatchExecutor {

  static final String LEAK_CANARY_THREAD_NAME = "LeakCanary-Heap-Dump";
  private final Handler mainHandler;
  private final Handler backgroundHandler;
  private final long initialDelayMillis;
  private final long maxBackoffFactor;

  public AndroidWatchExecutor(long initialDelayMillis) {
    // 1. 创建一个主现场的Handler对象
    mainHandler = new Handler(Looper.getMainLooper());
    // 2. 创建一个字线程
    HandlerThread handlerThread = new HandlerThread(LEAK_CANARY_THREAD_NAME);
    handlerThread.start();
    // 3.基于字线程handlerThread创建一个关联的Handler对象backgroundHandler
    backgroundHandler = new Handler(handlerThread.getLooper());
    this.initialDelayMillis = initialDelayMillis;
    maxBackoffFactor = Long.MAX_VALUE / initialDelayMillis;
  }

  @Override public void execute(@NonNull Retryable retryable) {
    // 1. 如果是主现场，则调用waitForIdle方法
    if (Looper.getMainLooper().getThread() == Thread.currentThread()) {
      waitForIdle(retryable, 0);
    } else {
      // 2. 通过mainHandler 执行一个异步任务
      postWaitForIdle(retryable, 0);
    }
  }
}

private void postWaitForIdle(final Retryable retryable, final int failedAttempts) {
  mainHandler.post(new Runnable() {
    @Override public void run() {
      waitForIdle(retryable, failedAttempts);
    }
  });
}
```

在**execute()**方法中，会进行主线程的判断，如果是主线程，则直接执行**waitForIdle()**方法，如果不是，则会通过handler发送一个消息，最终还是会调用**waitForIdle()**方法。



## 3-5、AndroidWatchExecutor的waitForIdle()方法：

```java
private void waitForIdle(final Retryable retryable, final int failedAttempts) {
  // This needs to be called from the main thread.
  Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() {
    @Override public boolean queueIdle() {
      postToBackgroundWithDelay(retryable, failedAttempts);
      return false;
    }
  });
}
```

这里的逻辑非常简单，就是往主线程的MessageQueue中，增加一个主线程任务都执行完成的回调。则在主线程任务都执行完成之后，就会执行**MessageQueue.IdleHandle**r的**queueIdle()**方法：

```java
private void postToBackgroundWithDelay(final Retryable retryable, final int failedAttempts) {
  long exponentialBackoffFactor = (long) Math.min(Math.pow(2, failedAttempts), maxBackoffFactor);
  long delayMillis = initialDelayMillis * exponentialBackoffFactor;
  // 在主线程空闲的时候，开始分析内存，backgroundHandler是一个与字线程关联的Handler，所以通过backgroundHandler发出的任务，都运行在字线程中
  backgroundHandler.postDelayed(new Runnable() {
    @Override public void run() {
      Retryable.Result result = retryable.run();// 字线程运行
      if (result == RETRY) {
        postWaitForIdle(retryable, failedAttempts + 1);
      }
    }
  }, delayMillis);// 延时处理，默认是5s钟
}
```

在这个方法中，通过backgroundHandler发送一个任务到字线程中，最终执行Retryable的run方法。这就回到了：**3-3、RefWatcher#的ensureGoneAsync方法**的Retryable的run()方法。这里再次贴一下代码：

```java
private void ensureGoneAsync(final long watchStartNanoTime, final KeyedWeakReference reference) {
  watchExecutor.execute(new Retryable() {
    @Override public Retryable.Result run() {
      return ensureGone(reference, watchStartNanoTime);
    }
  });
}
```



AndroidWatchExecutor的waitForIdle()方法，是在等主线程空闲的时候，开始分析内存泄漏，分析内存泄漏的逻辑又通过一个字线程的handler转到了字线程中，因此，内存泄漏的分析逻辑在字线程中运行。



在执行**Retryable**的**run()**方法的时候，会执行RefWatcher#ensureGone()方法。



## 3-6、RefWatcher#ensureGone()方法

```java
Retryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) {
  long gcStartNanoTime = System.nanoTime();
  long watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime);

  // 1. 先移除被回收的弱引用对象
  removeWeaklyReachableReferences();

  if (debuggerControl.isDebuggerAttached()) {
    // The debugger can create false leaks.
    return RETRY;
  }
  // 2. 如果没有内存泄漏
  if (gone(reference)) {
    return DONE;
  }
  
  // 3. 执行GC操作
  gcTrigger.runGc();
  
  // 4. 再次移除被回收的弱引用对象
  removeWeaklyReachableReferences();
  
  // 5. 如果有内存泄漏
  if (!gone(reference)) {
    long startDumpHeap = System.nanoTime();
    long gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime);

    // 6. 通过heapDumper对象，保存hprof文件
    File heapDumpFile = heapDumper.dumpHeap();
    if (heapDumpFile == RETRY_LATER) {
      // Could not dump the heap.
      return RETRY;
    }
    long heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);

    // 7. 构建一个代表hprof文件的HeapDump对象
    HeapDump heapDump = heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key)
        .referenceName(reference.name)
        .watchDurationMs(watchDurationMs)
        .gcDurationMs(gcDurationMs)
        .heapDumpDurationMs(heapDumpDurationMs)
        .build();

    // 8. 分析这个hprof文件
    heapdumpListener.analyze(heapDump);
  }
  return DONE;
}
```

通过上面的代码注解，我们可以知道，**ensureGone()**方法分为8个步骤来处理业务。首先，我们来看看**removeWeaklyReachableReferences**方法的处理逻辑。



### 3-6-1、RefWatcher#removeWeaklyReachableReferences()方法

```java
private void removeWeaklyReachableReferences() {
  // WeakReferences are enqueued as soon as the object to which they point to becomes weakly
  // reachable. This is before finalization or garbage collection has actually happened.
  KeyedWeakReference ref;
  while ((ref = (KeyedWeakReference) queue.poll()) != null) { // queue是与弱引用关联的引用队列
    retainedKeys.remove(ref.key); // 在Set集合中移除代表对象的key值
  }
}
```

在**# 3-2、ActivityRefWatcher#watch()方法**中，创建弱引用对象的时候，把弱引用与一个引用队列进行了关联，则被弱引用包裹的对象被回收的时候，这个弱引用对象就会被放入到这个引用队列中来。



在这里，我们遍历这个引用队列，遍历出来的弱引用对象，其引用的对象都是被回收了的对象，所以这里把代表被回收的对象的唯一key值从Set集合中移除。



### 3-6-2、RefWatcher#gone()方法

所以我们要判断一个对象是否内存泄漏了，就可以拿代表这个对象的唯一key值到Set集合中去找，看是否存在，如果存在，说明这个key的对象还没有被回收。下面，我们就看看gone()方法中的逻辑是否如我们猜想的这样：



```java
/**
*	判断对象是否被回收
* @return true：对象已经被回收了，false：对象还没有被回收
*/
private boolean gone(KeyedWeakReference reference) {
  return !retainedKeys.contains(reference.key); // 这里就是判断代表对象的唯一key值是否在Set集合中存在
}
```

若果key值在Set集合中存在，则gone方法返回false，则表示对象还没有被回收；如果key值不在集合中，则gone方法返回true，表示对象已经被回收了。



执行GC操作，再次从Set集合中移除被回收的对象的key值，再次判断对象是否被回收，如果对象还是没有被回收，则保存内存快照，生产hprof文件。



### 3-6-3、AndroidHeapDumper# dumpHeap()方法

```java
public File dumpHeap() {
  // 1. 创建一个用于保存hprof文件的file对象
  File heapDumpFile = leakDirectoryProvider.newHeapDumpFile();

  if (heapDumpFile == RETRY_LATER) {// 2.如果这个文件等于RETRY_LATER则表示生成失败，直接返回RETRY进行延时重试检测的操作
    return RETRY_LATER;
  }

  FutureResult<Toast> waitingForToast = new FutureResult<>();
  showToast(waitingForToast);

  if (!waitingForToast.wait(5, SECONDS)) {
    CanaryLog.d("Did not dump heap, too much time waiting for Toast.");
    return RETRY_LATER;
  }

  Notification.Builder builder = new Notification.Builder(context)
      .setContentTitle(context.getString(R.string.leak_canary_notification_dumping));
  Notification notification = LeakCanaryInternals.buildNotification(context, builder);
  NotificationManager notificationManager =
      (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
  int notificationId = (int) SystemClock.uptimeMillis();
  notificationManager.notify(notificationId, notification);

  Toast toast = waitingForToast.get();
  try {
    // 2. 保存hprof文件
    Debug.dumpHprofData(heapDumpFile.getAbsolutePath());
    cancelToast(toast);
    notificationManager.cancel(notificationId);
    return heapDumpFile;
  } catch (Exception e) {
    CanaryLog.d(e, "Could not dump heap");
    // Abort heap dump
    return RETRY_LATER;
  }
}
```

这个方法里面的代码有很多，我们只需要重点关注注释处的代码即可：

* (1)、创建一个用于保存hprof文件的file对象
* (2)、如果这个文件等于RETRY_LATER则表示生成失败，直接返回RETRY进行延时重试检测的操作
* (3)、调用系统api：**Debug.dumpHprofData()**，保存hprof文件到指定的目录



如果hprof文件生成成功，就会调用heapDumpBuilder建造者创建一个代表hprof文件的HeapDump对象。通过前面的分析我们知道，heapDumpBuilder对象是HeapDump.Builder类型，在RefWatcherBuilder的默认构造函数中创建。



### 3-6-4、通过建造者：HeapDump.Builder构建一个代表hprof文件的HeapDump对象



```java
Retryable.Result ensureGone(final KeyedWeakReference reference, final long watchStartNanoTime) {
  // 。。。。。。。。。。。。。。。。。。。。。。。。
      HeapDump heapDump = heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key)
          .referenceName(reference.name)
          .watchDurationMs(watchDurationMs)
          .gcDurationMs(gcDurationMs)
          .heapDumpDurationMs(heapDumpDurationMs)
          .build();

      heapdumpListener.analyze(heapDump);
    }
    return DONE;
  }

// HeapDump.Builder的build方法
public HeapDump build() {
      checkNotNull(excludedRefs, "excludedRefs");
      checkNotNull(heapDumpFile, "heapDumpFile");
      checkNotNull(referenceKey, "referenceKey");
      checkNotNull(reachabilityInspectorClasses, "reachabilityInspectorClasses");
      return new HeapDump(this); // 创建一个HeapDump对象
    }

// HeapDump的构造函数
  HeapDump(Builder builder) {
    this.heapDumpFile = builder.heapDumpFile;
    this.referenceKey = builder.referenceKey;
    this.referenceName = builder.referenceName;
    this.excludedRefs = builder.excludedRefs;
    this.computeRetainedHeapSize = builder.computeRetainedHeapSize;
    this.watchDurationMs = builder.watchDurationMs;
    this.gcDurationMs = builder.gcDurationMs;
    this.heapDumpDurationMs = builder.heapDumpDurationMs;
    this.reachabilityInspectorClasses = builder.reachabilityInspectorClasses;
  }
```

第六步执行完后，就生成了一个HeapDump对象。



最后会执行heapdumpListener的analyze()对新创建的HeapDump对象进行泄漏分析。由前面对**AndroidRefWatcherBuilder**的**listenerServiceClass()**的分析可知，**heapdumpListener**的实现就是**ServiceHeapDumpListener**，接着看到ServiceHeapDumpListener的**analyze()**方法。



### 3-6-4、ServiceHeapDumpListener#analyze()方法：

```java
@Override public void analyze(@NonNull HeapDump heapDump) {
  checkNotNull(heapDump, "heapDump");
  HeapAnalyzerService.runAnalysis(context, heapDump, listenerServiceClass);
}
```

这里的逻辑很简单，就是把处理委托给了**HeapAnalyzerService**的**runAnalysis**方法去执行：

```java
public static void runAnalysis(Context context, HeapDump heapDump,
    Class<? extends AbstractAnalysisResultService> listenerServiceClass) {
  setEnabledBlocking(context, HeapAnalyzerService.class, true);
  setEnabledBlocking(context, listenerServiceClass, true);
  Intent intent = new Intent(context, HeapAnalyzerService.class);// 
  intent.putExtra(LISTENER_CLASS_EXTRA, listenerServiceClass.getName());// 携带DisplayLeakService的名字
  intent.putExtra(HEAPDUMP_EXTRA, heapDump);
  ContextCompat.startForegroundService(context, intent); // 启动服务：HeapAnalyzerService
}
```

**HeapAnalyzerService**的**runAnalysis**方法的逻辑也很简单，就是启动一个：HeapAnalyzerService服务。



## 3-7、HeapAnalyzerService服务启动

HeapAnalyzerService继承与ForegroundService服务，而ForegroundService服务又继承与IntentService，IntentService在启动的时候，会执行：onHandleIntent()方法。

**ForegroundService中重写了onHandleIntent()方法：**

```java
@Override protected void onHandleIntent(@Nullable Intent intent) {
  onHandleIntentInForeground(intent);
}

protected abstract void onHandleIntentInForeground(@Nullable Intent intent);
```



**接下来看HeapAnalyzerService的onHandleIntentInForeground()方法**：

```java
protected void onHandleIntentInForeground(@Nullable Intent intent) {
  if (intent == null) {
    CanaryLog.d("HeapAnalyzerService received a null intent, ignoring.");
    return;
  }
  // listenerClassName就是DisplayLeakService的名字
  String listenerClassName = intent.getStringExtra(LISTENER_CLASS_EXTRA);
  HeapDump heapDump = (HeapDump) intent.getSerializableExtra(HEAPDUMP_EXTRA);

  // 1. 首先会新建一个HeapAnalyzer对象，它会根据RefWatcher生成的heap dumps信息来分析被怀疑的泄漏是否是真的泄漏
  HeapAnalyzer heapAnalyzer =
      new HeapAnalyzer(heapDump.excludedRefs, this, heapDump.reachabilityInspectorClasses);

  // 2. 然后会调用它的checkForLeak()方法去使用haha库解析 hprof文件
  AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey,
      heapDump.computeRetainedHeapSize);
  
  // 3. 把分析结果显示出来
  AbstractAnalysisResultService.sendResultToListener(this, listenerClassName, heapDump, result);
}
```

从上面代码可以看出，注释1处，首先会新建一个HeapAnalyzer对象，顾名思义，它就是根据RefWatcher生成的heap dumps信息来分析被怀疑的泄漏是否是真的。在注释2处，然后会调用它的checkForLeak()方法去使用haha库解析 hprof文件。



## 3-8、HeapAnalyzer#checkForLeak()方法：

```java
public @NonNull AnalysisResult checkForLeak(@NonNull File heapDumpFile,
    @NonNull String referenceKey,
    boolean computeRetainedSize) {
  long analysisStartNanoTime = System.nanoTime();

  if (!heapDumpFile.exists()) { // 判断hprof文件是否存在
    Exception exception = new IllegalArgumentException("File does not exist: " + heapDumpFile);
    return failure(exception, since(analysisStartNanoTime));
  }

  try {
    listener.onProgressUpdate(READING_HEAP_DUMP_FILE);
    // 1. 新建一个内存映射缓存文件buffer
    HprofBuffer buffer = new MemoryMappedFileBuffer(heapDumpFile);
    // 2. 创建一个hprof文件解析器
    HprofParser parser = new HprofParser(buffer);
    listener.onProgressUpdate(PARSING_HEAP_DUMP);
    Snapshot snapshot = parser.parse();
    listener.onProgressUpdate(DEDUPLICATING_GC_ROOTS);
    // 3. 删除重复的GC root对象
    deduplicateGcRoots(snapshot);
    listener.onProgressUpdate(FINDING_LEAKING_REF);
    
    // 4. 查找泄漏的引用
    Instance leakingRef = findLeakingReference(referenceKey, snapshot);

    // False alarm, weak reference was cleared in between key check and heap dump.
    // 5. 如果没有找到泄漏的引用
    if (leakingRef == null) {
      String className = leakingRef.getClassObj().getClassName();
      return noLeak(className, since(analysisStartNanoTime)); // 返回一个没有泄漏的分析结果AnalysisResult对象
    }
    // 6. 返回一个有泄漏分析结果的AnalysisResult对象
    return findLeakTrace(analysisStartNanoTime, snapshot, leakingRef, computeRetainedSize);
  } catch (Throwable e) {
    return failure(e, since(analysisStartNanoTime));
  }
}
```

这个方法执行的逻辑有点复杂，主要分为如下6个步骤：

1. 新建一个内存映射缓存文件buffer对象
2. 根据第一步生成的buffer对象，创建一个hprof文件解析器。
3. 删除重复的GC Root对象
4. 查找泄漏的引用
5. 如果没有找到泄漏的引用对象，则返回一个没有泄漏的**AnalysisResult**对象
6. 如果有泄漏，则返回一个有泄漏的**AnalysisResult**对象。



最后，我们来分析下**HeapAnalyzerService**中**onHandleIntentInForeground**方法注释3处的**AbstractAnalysisResultService.sendResultToListener()**方法，很明显，这里AbstractAnalysisResultService的实现类就是我们刚开始分析的用于展示泄漏路径信息得**DisplayLeakService**对象。在里面直接创建一个由PendingIntent构建的泄漏通知用于供用户点击去展示详细的泄漏界面DisplayLeakActivity。



## 3-9、AbstractAnalysisResultService.sendResultToListener()方法：

```java
public static void sendResultToListener(@NonNull Context context,
    @NonNull String listenerServiceClassName,
    @NonNull HeapDump heapDump,
    @NonNull AnalysisResult result) {
  Class<?> listenerServiceClass;
  try {
    // listenerServiceClassName是DisplayLeakService
    listenerServiceClass = Class.forName(listenerServiceClassName);
  } catch (ClassNotFoundException e) {
    throw new RuntimeException(e);
  }
  Intent intent = new Intent(context, listenerServiceClass);

  File analyzedHeapFile = AnalyzedHeap.save(heapDump, result);
  if (analyzedHeapFile != null) {
    intent.putExtra(ANALYZED_HEAP_PATH_EXTRA, analyzedHeapFile.getAbsolutePath());
  }
  ContextCompat.startForegroundService(context, intent);// 这里就是启动DisplayLeakService
}
```

这里的处理逻辑很简单，就是启动DisplayLeakService服务。



## 3-10、DisplayLeakService启动之后，就会执行onHeapAnalyzed方法：

```java
protected final void onHeapAnalyzed(@NonNull AnalyzedHeap analyzedHeap) {
  HeapDump heapDump = analyzedHeap.heapDump;
  AnalysisResult result = analyzedHeap.result;

  String leakInfo = leakInfo(this, heapDump, result, true);
  CanaryLog.d("%s", leakInfo);

  heapDump = renameHeapdump(heapDump);
  // 1. 保存HeapDump对象和内存泄漏分析结果对象保存到指定的文件
  boolean resultSaved = saveResult(heapDump, result);

  String contentTitle;
  if (resultSaved) {// 保存成功
    // 2. 创建一个跳转到DisplayLeakActivity的Intent对象
    PendingIntent pendingIntent =
        DisplayLeakActivity.createPendingIntent(this, heapDump.referenceKey);
    if (result.failure != null) {
      contentTitle = getString(R.string.leak_canary_analysis_failed);
    } else {
      String className = classSimpleName(result.className);
      if (result.leakFound) {
        if (result.retainedHeapSize == AnalysisResult.RETAINED_HEAP_SKIPPED) {
          if (result.excludedLeak) {
            contentTitle = getString(R.string.leak_canary_leak_excluded, className);
          } else {
            contentTitle = getString(R.string.leak_canary_class_has_leaked, className);
          }
        } else {
          String size = formatShortFileSize(this, result.retainedHeapSize);
          if (result.excludedLeak) {
            contentTitle =
                getString(R.string.leak_canary_leak_excluded_retaining, className, size);
          } else {
            contentTitle =
                getString(R.string.leak_canary_class_has_leaked_retaining, className, size);
          }
        }
      } else {
        contentTitle = getString(R.string.leak_canary_class_no_leak, className);
      }
    }
    String contentText = getString(R.string.leak_canary_notification_message);
    // 3. 创建一个供用户点击跳转到DisplayLeakActivity的延时通知
    showNotification(pendingIntent, contentTitle, contentText);
  } else {
    onAnalysisResultFailure(getString(R.string.leak_canary_could_not_save_text));
  }

  afterDefaultHandling(heapDump, result, leakInfo);
}

// DisplayLeakActivity的createPendingIntent方法
public static PendingIntent createPendingIntent(Context context, String referenceKey) {
  setEnabledBlocking(context, DisplayLeakActivity.class, true);
  Intent intent = new Intent(context, DisplayLeakActivity.class);
  intent.putExtra(SHOW_LEAK_EXTRA, referenceKey);
  intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK | Intent.FLAG_ACTIVITY_CLEAR_TOP);
  return PendingIntent.getActivity(context, 1, intent, FLAG_UPDATE_CURRENT);
}
```



到此，LeakCanary源码分析完成。