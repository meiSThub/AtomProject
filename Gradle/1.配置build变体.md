[配置变体](https://developer.android.com/studio/build/build-variants?hl=zh-cn)

# 一、添加 build 依赖项

详情参考官方：[添加 build 依赖项](https://developer.android.com/studio/build/dependencies?hl=zh-cn)

**注意**：指定依赖项时，不应使用动态版本号，如 `'com.android.tools.build:gradle:3.+'`。使用此功能可能会导致意外的版本更新和难以解析版本差异。

## 1、依赖项类型

如需向您的项目添加依赖项，请在模块的 `build.gradle` 文件的 `dependencies` 代码块中指定依赖项配置，如 `implementation`。

例如，应用模块的以下 `build.gradle` 文件包含三种不同类型的依赖项：

```groovy
plugins {
  id 'com.android.application'
}

android { ... }

// 配置依赖项
dependencies {
    // Dependency on a local library module
    implementation project(':mylibrary')

    // Dependency on local binaries
    implementation fileTree(dir: 'libs', include: ['*.jar'])

    // Dependency on a remote binary
    implementation 'com.example.android:app-magic:12.3'
}
```

其中每种依赖项配置都要求不同种类的库依赖项，如下所示：

### 1-1、本地库模块依赖项

```groovy
implementation project(':mylibrary')
```

这声明了对一个名为“mylibrary”（此名称必须与您的 [`settings.gradle`](https://docs.gradle.org/current/dsl/org.gradle.api.initialization.Settings.html) 文件中使用 `include:` 定义的库名称相符）的 [Android 库模块](https://developer.android.com/studio/projects/android-library?hl=zh-cn)的依赖关系。 在构建您的应用时，构建系统会编译该库模块，并将生成的编译内容打包到应用中。

### 1-2、本地二进制文件依赖项

```groovy
  implementation fileTree(dir: 'libs', include: ['*.jar'])
```

Gradle 声明了对项目的 `module_name/libs/` 目录中 JAR 文件的依赖关系（因为 Gradle 会读取 `build.gradle` 文件的相对路径）。

或者，您也可以按如下方式指定各个文件：

```groovy
  implementation files('libs/foo.jar', 'libs/bar.jar')
```

### 1-3、远程二进制文件依赖项

```groovy
  implementation 'com.example.android:app-magic:12.3'
```

这实际上是以下代码的简写形式：

```groovy
  implementation group: 'com.example.android', name: 'app-magic', version: '12.3'
```

这声明了对“com.example.android”命名空间组内的 12.3 版“app-magic”库的依赖关系。

如果您在编译时依赖 AGP 依赖项，请务必将其添加为显式依赖项。由于 AGP 在内部使用 `api/implementation` 配置，因此某些工件可能会从您的编译类路径中移除，而编译类路径可能会更改。

### 1-4、原生依赖项

从 Android Gradle 插件 4.0 开始，也可以按照本文档所述的方式导入原生依赖项。

对提供原生库的 AAR 的依赖会自动使这些库可供 `externalNativeBuild` 所使用的构建系统使用。如要从代码访问这些库，您必须在原生构建脚本中链接到这些库。在本文档中，请参阅[使用原生依赖项](https://developer.android.com/studio/build/dependencies?hl=zh-cn#using-native-dependencies)。

## 2、依赖项配置

在 `dependencies` 代码块内，您可以从多种不同的依赖项配置中选择其一（如上面所示的 `implementation`）来声明库依赖项。每种依赖项配置都向 Gradle 提供了有关如何使用该依赖项的不同说明。下表介绍了您可以对 Android 项目中的依赖项使用的各种配置。此表还将这些配置与自 Android Gradle 插件 3.0.0 起废弃的配置进行了比较。

| 配置                  | 行为                                                         |
| :-------------------- | :----------------------------------------------------------- |
| `implementation`      | Gradle 会将依赖项添加到编译类路径，并将依赖项打包到构建输出。不过，当您的模块配置 `implementation` 依赖项时，会让 Gradle 了解您不希望该模块在编译时将该依赖项泄露给其他模块。也就是说，其他模块只有在运行时才能使用该依赖项。使用此依赖项配置代替 `api` 或 `compile`（已废弃）可以**显著缩短构建时间**，因为这样可以减少构建系统需要重新编译的模块数。例如，如果 `implementation` 依赖项更改了其 API，Gradle 只会重新编译该依赖项以及直接依赖于它的模块。大多数应用和测试模块都应使用此配置。 |
| `api`                 | Gradle 会将依赖项添加到编译类路径和构建输出。当一个模块包含 `api` 依赖项时，会让 Gradle 了解该模块**要以传递方式将该依赖项导出到其他模块**，以便这些模块在运行时和编译时都可以使用该依赖项。此配置的行为类似于 `compile`（现已废弃），但使用它时应格外小心，只能对您需要以传递方式导出到其他上游消费者的依赖项使用它。这是因为，如果 `api` 依赖项更改了其外部 API，Gradle 会在编译时重新编译所有有权访问该依赖项的模块。因此，拥有大量的 `api` 依赖项会显著增加构建时间。除非要将依赖项的 API 公开给单独的模块，否则库模块应改用 `implementation` 依赖项。 |
| `compileOnly`         | Gradle 只会将依赖项添加到编译类路径（也就是说，不会将其添加到构建输出）。如果您创建 Android 模块时在编译期间需要相应依赖项，但它在运行时可有可无，此配置会很有用。如果您使用此配置，那么您的库模块必须包含一个运行时条件，用于检查是否提供了相应依赖项，然后适当地改变该模块的行为，以使该模块在未提供相应依赖项的情况下仍可正常运行。这样做不会添加不重要的瞬时依赖项，因而有助于减小最终应用的大小。此配置的行为类似于 `provided`（现已废弃）。**注意**：您不能将 `compileOnly` 配置与 AAR 依赖项配合使用。 |
| `runtimeOnly`         | Gradle 只会将依赖项添加到 build 输出，以便在运行时使用。也就是说，不会将其添加到编译类路径。 此配置的行为类似于 `apk`（现已废弃）。 |
| `annotationProcessor` | 如需添加对作为注解处理器的库的依赖，您必须使用 `annotationProcessor` 配置将其添加到注解处理器的类路径。这是因为，使用此配置可以将编译类路径与注释处理器类路径分开，从而提高构建性能。如果 Gradle 在编译类路径上找到注解处理器，则会禁用[避免编译](https://docs.gradle.org/current/userguide/java_plugin.html#sec:java_compile_avoidance)功能，这样会对构建时间产生负面影响（Gradle 5.0 及更高版本会忽略在编译类路径上找到的注解处理器）。如果 JAR 文件包含以下文件，则 Android Gradle 插件会假定依赖项是注解处理器：`META-INF/services/javax.annotation.processing.Processor`如果插件检测到编译类路径上包含注解处理器，则会产生构建错误。**注意**：Kotlin 项目应[使用 kapt](https://kotlinlang.org/docs/reference/kapt.html) 声明注解处理器依赖项。 |
| `lintChecks`          | 使用此配置可以添加您希望 Gradle 在构建项目时执行的 lint 检查。**注意**：使用 Android Gradle 插件 3.4.0 及更高版本时，此依赖项配置不再将 lint 检查打包在 Android 库项目中。如需将 lint 检查依赖项包含在 AAR 库中，请使用下面介绍的 `lintPublish` 配置。 |
| `lintPublish`         | 在 Android 库项目中使用此配置可以添加您希望 Gradle 编译成 `lint.jar` 文件并打包在 AAR 中的 lint 检查。这会使得使用 AAR 的项目也应用这些 lint 检查。如果您之前使用 `lintChecks` 依赖项配置将 lint 检查添加到已发布的 AAR 中，则需要迁移这些依赖项以改用 `lintPublish` 配置。[Groovy](https://developer.android.com/studio/build/dependencies?hl=zh-cn#groovy)[Kotlin](https://developer.android.com/studio/build/dependencies?hl=zh-cn#kotlin)`dependencies { // Executes lint checks from the ':checks' project at build time. lintChecks project(':checks') // Compiles lint checks from the ':checks-to-publish' into a // lint.jar file and publishes it to your Android library. lintPublish project(':checks-to-publish')}` |
| `apk`                 | Gradle 只会将依赖项添加到 build 输出，以便在运行时使用。也就是说，不会将其添加到编译类路径。 此配置**已废弃**（在 AGP 1.0-4.2 中可用）。 |
| `compile`             | Gradle 会将依赖项添加到编译类路径和 build 输出，并将依赖项导出到其他模块。此配置**已废弃**（在 AGP 1.0-4.2 中可用）。 |
| `provided`            | Gradle 只会将依赖项添加到编译类路径（也就是说，不会将其添加到 build 输出）。此配置**已废弃**（在 AGP 1.0-4.2 中可用）。 |



以上所有配置会将依赖项应用于所有 build 变体。如果您只想为特定的[构建变体](https://developer.android.com/studio/build/build-variants?hl=zh-cn)源代码集或[测试源代码集](https://developer.android.com/studio/test?hl=zh-cn#sourcesets)声明依赖项，则必须将配置名称的首字母大写，并在其前面加上构建变体或测试源代码集的名称作为前缀，即：{productFlavor}{buildType}Implementation

例如，如需只向“free”产品变种添加 `implementation` 依赖项（使用远程二进制文件依赖项），请使用如下所示的代码：

```groovy
dependencies {
    freeImplementation 'com.google.firebase:firebase-ads:9.8.0'
}
```

不过，如果您想为 将产品变种和 build 类型 组合在一起的变体添加依赖项，就必须在 `configurations` 代码块中初始化**配置名称**。以下示例向“freeDebug”build 变体添加了 `runtimeOnly` 依赖项（使用本地二进制文件依赖项）。

```groovy
configurations {
    // Initializes a placeholder for the freeDebugRuntimeOnly dependency configuration.
    freeDebugRuntimeOnly {}
}

dependencies {
    freeDebugRuntimeOnly fileTree(dir: 'libs', include: ['*.jar'])
}
```

如需为本地测试和插桩测试添加 `implementation` 依赖项，请使用如下所示的代码：

```groovy
dependencies {
    // Adds a remote binary dependency only for local tests.
    testImplementation 'junit:junit:4.12'

    // Adds a remote binary dependency only for the instrumented test APK.
    androidTestImplementation 'androidx.test.espresso:espresso-core:3.0.2'
}
```

不过，某些配置在这种情况下没有意义。例如，因为其他模块不能依赖于 `androidTest`，所以如果您使用 `androidTestApi` 配置，会收到以下警告：

> ```shell
> WARNING: Configuration 'androidTestApi' is obsolete and has been replaced with
> 'androidTestImplementation'.
> ```

即：使用 `androidTestApi` 方法引用依赖没有意义，因为其他模块不能依赖于 `androidTest` 源代码集。

其他配置，可以查看官方文档：[添加 build 依赖项](https://developer.android.com/studio/build/dependencies?hl=zh-cn)

# 二、配置 build 变体

官方参考文档：[配置 build 变体](https://developer.android.com/studio/build/build-variants?hl=zh-cn)

本页以[配置 build 概览](https://developer.android.com/studio/build?hl=zh-cn)为基础，向您介绍如何通过配置 build 变体来根据单个项目构建出不同版本的应用，以及如何正确管理依赖项和签名配置。

每种 **`build 变体`** 都代表您可以构建的一个**不同的应用版本**。例如，您可能希望为应用构建两个版本，一个是内容有限的免费版本，另一个是包含更多内容的付费版本。您还可以根据 API 级别或其他设备变化因素，为应用构建以不同设备为目标的不同版本。

build 变体是 Gradle 使用 [一组特定规则](https://developer.android.com/studio/build/build-variants?hl=zh-cn#sourceset-build) 将在` buildType `和 `productFlavor` 中配置的设置、代码和资源组合在一起所得到的结果。虽然您无法直接配置 build 变体，但可以配置组成它们的 ` buildType `和 `productFlavor`。

例如，“demo” 产品变种可以指定不同的功能和设备要求（如自定义源代码、资源和最低 API 级别），而 “debug” 类型的 `buildType` 则会采用不同的构建和打包设置（如调试选项和签名密钥）。**生成的 build 变体是应用的“demoDebug”版本，它由“demo”产品变种、“debug”build 类型和 `main/` 源代码集中包含的配置和资源组合而成。**

## 1、配置 buildType

你可以在模块级 `build.gradle` 文件中的 `android` 代码块内创建和配置` buildType`。当您创建新`module`时，Android Studio 会自动为您创建 “debug” build 类型和“release”build 类型。虽然“debug”build 类型没有出现在 build 配置文件中，但 Android Studio 会使用 [`debuggable true`](https://developer.android.com/guide/topics/manifest/application-element?hl=zh-cn#debug) 配置它。这样，您就可以在安全的 Android 设备上调试应用，并使用常规调试密钥库配置应用签名。

如果您要添加或更改某些设置，可以将“debug”build 类型添加到配置中。以下示例为“debug”build 类型指定了 [`applicationIdSuffix`](https://developer.android.com/studio/build/build-variants?hl=zh-cn#change-app-id)，并配置了一个使用“debug”build 类型的设置进行初始化的“staging”build 类型。

```groovy
android {
    defaultConfig {
        manifestPlaceholders = [hostName:"www.example.com"]
        ...
    }
    buildTypes {
        release {
            minifyEnabled true
            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
        }

        debug {
            applicationIdSuffix ".debug" // 设置debug包的应该id
            debuggable true
        }

        /**
         * initWith debug：以debug的配置进行初始化，即把debug中的配置，全部复制到 staging 中，并定制化自己的配置
         */
        staging {
            initWith debug
            manifestPlaceholders = [hostName:"internal.example.com"]
            applicationIdSuffix ".debugStaging"
        }
    }
}
```

如需详细了解您可以通过 build 类型配置的所有属性，请参阅 [build 类型 DSL 参考文档](https://developer.android.com/reference/tools/gradle-api/current/com/android/build/api/dsl/BuildType?hl=zh-cn)。

## 2、配置产品变种

创建 `productFlavors` 与创建 `buildTypes`类似：在 module 的 build.gradle文件中的`android`闭包中，添加 `productFlavors` 代码块并配置所需的设置。**产品变种支持与 `defaultConfig` 相同的属性**，这是因为，`defaultConfig` 实际上属于 [`ProductFlavor`](https://developer.android.com/reference/tools/gradle-api/current/com/android/build/api/dsl/ProductFlavor?hl=zh-cn) 类。这意味着，您可以在 `defaultConfig` 代码块中提供所有变种的基本配置，每个变种均可更改其中任何默认值，如 `applicationId`。如需详细了解应用 ID，请参阅[设置应用 ID](https://developer.android.com/studio/build/configure-app-module?hl=zh-cn#set_the_application_id)。

> **注意**：您仍然需要在 `main/` 清单文件中使用 [`package`](https://developer.android.com/guide/topics/manifest/manifest-element?hl=zh-cn#package) 属性指定软件包名称。此外，您还必须在源代码中使用该软件包名称引用 R 类，或解析任何相关的 Activity 或服务注册。这样，您就可以使用 `applicationId` 为每个产品变种指定一个唯一的 ID，以用于打包和分发，而不必更改源代码。

所有变种都必须属于一个指定的 **变种维度**，即一个**产品变种组**，即给**产品变种**指定一个分组。您必须将所有变种分配给某个变种维度；否则，您将收到如下所示的构建错误。如果给定的模块仅指定一个变种维度，那么 Android Gradle 插件会自动将该模块的所有变种分配给该维度。

> ```shell
>  Error:All flavors must now belong to a named flavor dimension.
>   The flavor 'flavor_name' is not assigned to a flavor dimension.
> ```

> **提示**：插件会尝试将应用的变体与本地库依赖项的变体进行匹配。由于[变体感知型依赖项匹配机制](https://developer.android.com/studio/build/build-variants?hl=zh-cn#variant_aware)依赖于您为变种维度命名的方式，因此您应**谨慎地为变种维度命名**。这样做可让您更好地控制来自本地依赖项的哪些代码和资源与应用的各个版本匹配。

以下代码示例创建了一个名为“version”的变种维度，并添加了“demo”和“full”产品变种。这些变种提供了它们自己的 [`applicationIdSuffix`](https://developer.android.com/studio/build/build-variants?hl=zh-cn#change-app-id) 和 [`versionNameSuffix`](https://developer.android.com/reference/tools/gradle-api/current/com/android/build/api/dsl/ProductFlavor?hl=zh-cn)：

```groovy
android {
    ...
    defaultConfig {...}
    buildTypes {
        debug{...}
        release{...}
    }
    // 声明变种维度
    flavorDimensions "version"
    productFlavors {
        demo {
            // Assigns this product flavor to the "version" flavor dimension.
            // If you are using only one dimension, this property is optional,
            // and the plugin automatically assigns all the module's flavors to
            // that dimension.
            dimension "version"	// 指定当前产品变种所属的变种维度
            applicationIdSuffix ".demo"
            versionNameSuffix "-demo"
        }
        full {
            dimension "version"
            applicationIdSuffix ".full"
            versionNameSuffix "-full"
        }
    }
}
```

> **注意**：对于使用 APK 在 Google Play 上进行分发的旧版应用（创建于 2021 年 8 月之前），如需在 Google Play 中使用[多 APK 支持](https://developer.android.com/google/play/publishing/multiple-apks?hl=zh-cn)功能分发应用，请将相同的 `applicationId` 值赋予所有变体，并为每个变体分别指定一个不同的 [`versionCode`](https://developer.android.com/studio/publish/versioning?hl=zh-cn#appversioning)。如需在 Google Play 中以独立应用的形式分发应用的不同变体，您需要为每个变体分配一个不同的 `applicationId`。

创建并配置产品变种后，点击通知栏中的 **Sync Now**。同步完成后，Gradle 会根据 build 类型和产品变种自动创建 build 变体，并按照 `<product-flavor><Build-Type>` 为其命名。例如，如果您创建了“demo”和“full”产品变种，并保留了默认的“debug”build 类型和“release”build 类型，Gradle 会创建以下 build 变体：

- demoDebug
- demoRelease
- fullDebug
- fullRelease

您可以将 build 变体更改为您要构建并运行的任意变体，只需依次转到 **Build** > **Select Build Variant**，然后从下拉菜单中选择一个变体即可。不过，如需开始使用每个 build 变体自己的功能和资源对其进行自定义，您需要知道如何[创建和管理源代码集](https://developer.android.com/studio/build/build-variants?hl=zh-cn#sourcesets)。

![image-20221214182753131](https://raw.githubusercontent.com/meiSThub/BlogImage/master/2022/image-20221214182753131.png)

### 2-1、更改 build 变体的应用 ID

当您为应用构建 APK 或 AAB 时，构建工具会使用 `build.gradle` 文件的 `defaultConfig` 代码块中定义的应用 ID 标记应用（如下所示）。不过，如果您想创建不同版本的应用，使它们在 Google Play 商店中以单独的详情进行显示（如“free”和“pro”版本），就需要创建具有不同应用 ID 的多个单独的 [build 变体](https://developer.android.com/studio/build/build-variants?hl=zh-cn)。在这种情况下，每个 build 变体应定义为单独的[产品变种](https://developer.android.com/studio/build/build-variants?hl=zh-cn#product-flavors)。对于 `productFlavors` 块中的每个变种，您可以重新定义 `applicationId` 属性，也可以使用 `applicationIdSuffix` 在默认的应用 ID 上追加一段，如下所示：

```groovy
android {
    defaultConfig {
        applicationId "com.example.myapp"
    }
    productFlavors {
        free {
            applicationIdSuffix ".free"
        }
        pro {
            applicationIdSuffix ".pro"
        }
    }
}
```

这样，“free”产品变种的应用 ID 就是“com.example.myapp.free”。 您也可以根据自己的 [build 类型](https://developer.android.com/studio/build/build-variants?hl=zh-cn#build-types)使用 `applicationIdSuffix` 追加一段，如下所示：

```groovy
android {
    ...
    buildTypes {
        debug {
            applicationIdSuffix ".debug"
        }
    }
}
```

由于 Gradle 会在产品变种后面应用 `buildType` 配置，因此“free debug”build 变体的应用 ID 现在是“com.example.myapp.free.debug”。如果您希望同一设备上同时具有调试 build 和发布 build，这会很有用，因为两个应用不能具有相同的应用 ID。 对于使用 APK 在 Google Play 上进行分发的旧版应用（创建于 2021 年 8 月之前），如果您想使用相同的应用详情分发多个 APK，并让每个 APK 都以不同的设备配置（例如 API 级别）作为目标，则您必须对所有 build 变体使用相同的应用 ID，但为每个 APK 分别指定一个不同的 `versionCode`。如需了解详情，请参阅[多 APK 支持](https://developer.android.com/google/play/publishing/multiple-apks?hl=zh-cn)。如果您使用 AAB 进行发布，则不会受到任何影响，因为 AAB 使用单个工件，而该工件默认使用单个版本代码和应用 ID。

> **注意**：为了与以前的 SDK 工具兼容，如果您未在 `build.gradle` 文件中定义 `applicationId` 属性，构建工具会将 `AndroidManifest.xml` 文件中的软件包名称用作应用 ID。在这种情况下，重构您的软件包名称也会更改您的应用 ID。

> **提示**：如果需要在清单文件中引用应用 ID，您可以在任何清单属性中使用 `${applicationId}` 占位符。在构建期间，Gradle 会将此标记替换为实际的应用 ID。如需了解详情，请参阅[将 build 变量注入清单](https://developer.android.com/studio/build/manage-manifests?hl=zh-cn#inject_build_variables_into_the_manifest)。

### 2-2、将多个产品变种与变种维度组合在一起

在某些情况下，您可能要将多个产品变种的配置组合在一起。例如，您可能要为基于 API 级别的“full”和“demo”产品变种创建不同的配置。为此，您可以使用 Android Plugin for Gradle 创建多组产品变种作为变种维度。在构建应用时，Gradle 会将您定义的每个变种维度中的产品变种配置以及 build 类型配置组合在一起，以创建最终的 build 变体。Gradle 不会将属于同一变种维度的产品变种组合在一起。

以下代码示例使用 [`flavorDimensions`](https://developer.android.com/reference/tools/gradle-api/current/com/android/build/api/dsl/ProductFlavor?hl=zh-cn#dimension) 属性创建“mode”变种维度和“api”变种维度，前者用于对“full”和“demo”产品变种进行**分组**，后者用于根据 API 级别对产品变种配置进行分组：

```groovy
android {
  ...
  buildTypes {
    debug {...}
    release {...}
  }

  // Specifies the flavor dimensions you want to use. The order in which you
  // list each dimension determines its priority, from highest to lowest,
  // when Gradle merges variant sources and configurations. You must assign
  // each product flavor you configure to one of the flavor dimensions.
  flavorDimensions "api", "mode"

  productFlavors {
    demo {
      // Assigns this product flavor to the "mode" flavor dimension.
      dimension "mode"
      ...
    }

    full {
      dimension "mode"
      ...
    }

    // Configurations in the "api" product flavors override those in "mode"
    // flavors and the defaultConfig block. Gradle determines the priority
    // between flavor dimensions based on the order in which they appear next
    // to the flavorDimensions property above--the first dimension has a higher
    // priority than the second, and so on.
    minApi24 {
      dimension "api"
      minSdkVersion 24
      // To ensure the target device receives the version of the app with
      // the highest compatible API level, assign version codes in increasing
      // value with API level. To learn more about assigning version codes to
      // support app updates and uploading to Google Play, read Multiple APK Support
      versionCode 30000 + android.defaultConfig.versionCode
      versionNameSuffix "-minApi24"
      ...
    }

    minApi23 {
      dimension "api"
      minSdkVersion 23
      versionCode 20000  + android.defaultConfig.versionCode
      versionNameSuffix "-minApi23"
      ...
    }

    minApi21 {
      dimension "api"
      minSdkVersion 21
      versionCode 10000  + android.defaultConfig.versionCode
      versionNameSuffix "-minApi21"
      ...
    }
  }
}
...
```

Gradle 创建的 build 变体数量等于每个变种维度中的变种数量与您配置的 `buildType` 数量的乘积。当 Gradle 为每个 build 变体或对应的工件命名时，先显示属于较高优先级变种维度的产品变种，接着是较低优先级维度中的产品变种，再接着是  `buildType`。以上面的 build 配置为例，Gradle 使用以下命名方案创建了总共 12 个 build 变体：

* build 变体：`[minApi24, minApi23, minApi21][Demo, Full][Debug, Release]`

* 对应的 APK：`app-[minApi24, minApi23, minApi21]-[demo, full]-[debug, release].apk`

**例如，**

* build 变体：`minApi24DemoDebug`

* 对应的 APK：`app-minApi24-demo-debug.apk`

除了可以为各个产品变种和 build 变体创建源代码集目录之外，您还可以为产品变种的每个组合创建源代码集目录。例如，您可以创建 Java 源代码并将其添加到 `src/demoMinApi24/java/` 目录中，**只有在构建将这两个产品变种组合在一起的变体时，Gradle 才会使用这些源代码**。您为产品变种组合创建的源代码集的优先级高于属于各个产品变种的源代码集。如需详细了解源代码集以及 Gradle 如何合并资源，请参阅关于如何[创建源代码集](https://developer.android.com/studio/build/build-variants?hl=zh-cn#sourcesets)的部分。

> build 变体 > build 类型 > 产品变种 > 主源代码集 > 库依赖项

左侧源代码集替换右侧源代码集的文件和设置。

### 2-3、过滤变体

Gradle 会根据你配置的产品变种和 build 类型的每种可能组合创建一个 build 变体。不过，某些 build 变体可能并不是您需要的，或者对于您的项目来说没有意义。您可以在模块级 `build.gradle` 文件中创建变体过滤器，以移除某些 build 变体配置。

以上一部分中的 build 配置为例，假设您打算让“demo”版应用仅支持 API 级别 23 及更高级别，您可以使用 [`variantFilter`](https://developer.android.com/reference/tools/gradle-api/current/com/android/build/api/variant/VariantFilter?hl=zh-cn) 代码块过滤掉所有将“minApi21”和“demo”产品变种组合在一起的 build 变体配置：

```groovy
android {
  ...
  buildTypes {...}

  flavorDimensions "api", "mode"
  productFlavors {
    demo {...}
    full {...}
    minApi24 {...}
    minApi23 {...}
    minApi21 {...}
  }

  variantFilter { variant ->
      def names = variant.flavors*.name
      // To check for a certain build type, use variant.buildType.name == "<buildType>"
      if (names.contains("minApi21") && names.contains("demo")) {
          // Gradle ignores any variants that satisfy the conditions above.
          setIgnore(true) // 忽略该变体
      }
  }
}
...
```

将变体过滤器添加到 build 配置并点击通知栏中的 **Sync Now** 后，Gradle 会忽略符合您指定的条件的所有 build 变体，并且当您从菜单栏中依次点击 **Build > Select Build Variant**（或点击工具窗口栏中的 **Build Variants** 图标 ![image-20221214185356940](https://raw.githubusercontent.com/meiSThub/BlogImage/master/2022/image-20221214185356940.png)时，它们不会再显示在下拉菜单中。

## 3、创建源代码集

默认情况下，Android Studio 会为您希望在所有 build 变体之间共享的所有内容创建 `main/` [源代码集](https://developer.android.com/studio/build?hl=zh-cn#sourcesets)和目录。不过，您可以创建新的源代码集以精确控制 Gradle 为特定 build 类型、产品变种（以及使用[变种维度](https://developer.android.com/studio/build/build-variants?hl=zh-cn#flavor-dimensions)时的产品变种组合）和 build 变体编译和打包的文件。例如，您可以在 `main/` 源代码集中定义基本功能，并使用产品变种源代码集针对不同客户端更改应用的品牌信息，或仅为使用“debug”build 类型的 build 变体添加特殊权限和日志记录功能。

Gradle 要求您以某种类似于 `main/` 源代码集的方式组织源代码集文件和目录。例如，Gradle 要求将“debug”build 类型特有的 Java 类文件放在 `src/debug/java/` 目录中。

Android Plugin for Gradle 提供了一项有用的 Gradle 任务，可向您展示如何整理每个 build 类型、产品变种和 build 变体的文件。例如，任务输出中的以下示例描述了 Gradle 希望在何处能够找到“debug” `buildType`的某些文件：

```shell
------------------------------------------------------------
Project :app
------------------------------------------------------------

...

debug
----
Compile configuration: compile
build.gradle name: android.sourceSets.debug
Java sources: [app/src/debug/java]
Manifest file: app/src/debug/AndroidManifest.xml
Android resources: [app/src/debug/res]
Assets: [app/src/debug/assets]
AIDL sources: [app/src/debug/aidl]
RenderScript sources: [app/src/debug/rs]
JNI sources: [app/src/debug/jni]
JNI libraries: [app/src/debug/jniLibs]
Java-style resources: [app/src/debug/resources]
```

如需查看此输出，请按以下步骤操作：

1. 点击 IDE 窗口右侧的 **Gradle**。
2. 依次转到 **MyApplication > Tasks > android**，然后双击 **sourceSets**。如需查看 **Tasks** 文件夹，您必须允许 Gradle 在同步期间构建任务列表，方法是依次点击 **File > Settings > Experimental**，然后取消选中 **Do not build Gradle task list during Gradle sync** 复选框（在 macOS 设备上依次点击 **Android Studio > Preferences > Experimental**）。 Gradle 执行该任务后，系统应该会打开 **Run** 窗口以显示输出。
3. 如果显示内容不是处于如上所示的文本模式，请点击 **Run** 窗口左侧的 **Toggle view** 图标 ![img](https://raw.githubusercontent.com/meiSThub/BlogImage/master/2022/build-toggle_view-2x.png)。

**注意**：任务输出还为您展示了如何组织要用于运行应用测试的文件的源代码集，例如 `test/` 和 `androidTest/` [测试源代码集](https://developer.android.com/studio/test/advanced-test-setup?hl=zh-cn)。

当您创建新的 build 变体时，Android Studio 不会为您创建源代码集目录，而是为您提供一些有用的选项。例如，如需仅为“debug”build 类型创建 `java/` 目录，请执行以下操作：

1. 打开 **Project** 窗格，然后从窗格顶部的下拉菜单中选择 **Project** 视图。
2. 转到 `MyProject/app/src/`。
3. 右键点击 `src` 目录，然后依次选择 **New** > **Directory**。
4. 从 **Gradle Source Sets** 下选择 **debug/java**。
5. 按 Enter 键。

Android Studio 会为“debug”build 类型创建源代码集目录，然后在其中创建 `java/` 目录。或者，您也可以让 Android Studio 在您为特定 build 变体向项目中添加新文件时为您创建这些目录。例如，如需为“debug”build 类型创建值 XML 文件，请执行以下操作：

1. 在同一 **Project** 窗格中，右键点击 `src` 目录，然后依次选择 **New** > **XML** > **Values XML File**。
2. 输入 XML 文件的名称或保留默认名称。
3. 从 **Target Source Set** 旁边的下拉菜单中，选择 **debug**。
4. 点击 **Finish**。

由于“debug”build 类型被指定为目标源代码集，因此 Android Studio 会在创建 XML 文件时自动创建必要的目录。生成的目录结构应如图 2 所示。

![img](https://raw.githubusercontent.com/meiSThub/BlogImage/master/2022/debug-directories_2-1_2x.png)

遵循相同的过程，您也可以创建产品变种的源代码集目录（如 `src/demo/`）和 build 变体的源代码集目录（如 `src/demoDebug/`）。此外，您还可以创建针对特定 build 变体的测试源代码集，如 `src/androidTestDemoDebug/`。如需了解详情，请参阅[测试源代码集](https://developer.android.com/studio/test/advanced-test-setup?hl=zh-cn)一文。

### 3-1、更改默认源代码集配置

如果您的源代码未按照 Gradle 要求的默认源代码集文件结构进行组织（如上文关于[创建源代码集](https://developer.android.com/studio/build/build-variants?hl=zh-cn#sourcesets)的部分中所述），您可以使用 [`sourceSets`](https://developer.android.com/reference/tools/gradle-api/current/com/android/build/api/dsl/AndroidSourceSet?hl=zh-cn) 代码块更改 Gradle 为源代码集的每个组件收集文件的位置。`sourceSets` 代码块必须位于 `android` 代码块中。您无需改变源代码文件的位置，只需向 Gradle 提供相对于模块级 `build.gradle` 文件的路径，Gradle 应该会在该路径下找到每个源代码集组件的文件。如需了解您可以配置哪些组件，以及是否可以将它们映射到多个文件或目录，请参阅 [Android Gradle 插件 API 参考文档](https://developer.android.com/reference/tools/gradle-api?hl=zh-cn)。

以下代码示例将 `app/other/` 目录中的源代码映射到了 `main` 源代码集的某些组件，并更改了 `androidTest` 源代码集的根目录。

```groovy
android {
  ...
  sourceSets {
    // Encapsulates configurations for the main source set.
    main {
      // Changes the directory for Java sources. The default directory is
      // 'src/main/java'.
      java.srcDirs = ['other/java']

      // If you list multiple directories, Gradle uses all of them to collect
      // sources. Because Gradle gives these directories equal priority, if
      // you define the same resource in more than one directory, you get an
      // error when merging resources. The default directory is 'src/main/res'.
      res.srcDirs = ['other/res1', 'other/res2']

      // Note: You should avoid specifying a directory which is a parent to one
      // or more other directories you specify. For example, avoid the following:
      // res.srcDirs = ['other/res1', 'other/res1/layouts', 'other/res1/strings']
      // You should specify either only the root 'other/res1' directory, or only the
      // nested 'other/res1/layouts' and 'other/res1/strings' directories.

      // For each source set, you can specify only one Android manifest.
      // By default, Android Studio creates a manifest for your main source
      // set in the src/main/ directory.
      manifest.srcFile 'other/AndroidManifest.xml'
      ...
    }

    // Create additional blocks to configure other source sets.
    androidTest {

      // If all the files for a source set are located under a single root
      // directory, you can specify that directory using the setRoot property.
      // When gathering sources for the source set, Gradle looks only in locations
      // relative to the root directory you specify. For example, after applying the
      // configuration below for the androidTest source set, Gradle looks for Java
      // sources only in the src/tests/java/ directory.
      setRoot 'src/tests'
      ...
    }
  }
}
...
```

请注意，一个源目录只能属于一个源代码集。例如，您不能同时与 `test` 和 `androidTest` 源代码集共享同一测试源代码。这是因为 Android Studio 会为每个源代码集创建单独的 IntelliJ 模块，并且无法支持在不同的源代码集之间使用重复内容根目录。

### 3-2、使用源代码集构建

您可以让源代码集目录包含您希望只针对某些配置打包在一起的代码和资源。例如，如果您要构建“demoDebug”build 变体（“demo”产品变种和“debug”build 类型的混合产物），Gradle 会查看这些目录，并为它们指定以下优先级：

1. `src/demoDebug/`（build 变体源代码集）
2. `src/debug/`（build 类型源代码集）
3. `src/demo/`（产品变种源代码集）
4. `src/main/`（主源代码集）

为产品变种组合创建的源代码集必须包含**所有**变种维度。例如，build 变体源代码集必须是（build 类型 + 所有变种维度）的组合。不支持合并涉及的文件夹涵盖多个（但并非全部）变种维度的代码和资源。

代码资源合并选取优先级：

> build 变体 > build 类型 > 产品变种 > 主源代码集 > 库依赖项

左侧源代码集替换右侧源代码集的文件和设置。

**注意**：如果您[将多个产品变种组合在一起](https://developer.android.com/studio/build/build-variants?hl=zh-cn#flavor-dimensions)，那么这些产品变种的优先级由它们所属的变种维度决定。使用 [`android.flavorDimensions`](https://developer.android.com/reference/tools/gradle-api/current/com/android/build/api/dsl/ProductFlavor?hl=zh-cn#dimension) 属性列出变种维度时，属于您列出的第一个变种维度的产品变种的优先级高于属于第二个变种维度的产品变种，依此类推。此外，您为**产品变种组合**创建的源代码集的优先级**高于**属于**单个产品变种**的源代码集。

上面列出的顺序决定了 Gradle 组合代码和资源时哪个源代码集的优先级更高。由于 `demoDebug/` 源代码集目录很可能包含该 build 变体特有的文件，因此如果 `demoDebug/` 包含的某个文件在 `debug/` 中也进行了定义，Gradle 会使用 `demoDebug/` 源代码集中的文件。同样，Gradle 会为 build 类型和产品变种源代码集中的文件指定比 `main/` 中的相同文件更高的优先级。在应用以下构建规则时，Gradle 会考虑这种优先级顺序：

- `java/`目录中的所有源代码将一起编译以生成单个输出。
  
  > **注意**：对于给定的 build 变体，如果 Gradle 遇到两个或更多个源代码集目录定义了同一个 Java 类的情况，就会抛出构建错误。例如，在构建调试应用时，您不能同时定义 `src/debug/Utility.java` 和 `src/main/Utility.java`。这是因为，Gradle 在构建过程中会查看这两个目录并抛出“重复类”错误。如果您希望不同的 build 类型有不同版本的 `Utility.java`，就应让每个 build 类型定义各自的文件版本，而不是将其包含在 `main/` 源代码集中。
  
- 所有清单文件(`AndroidManifest.xml`)都将合并为一个清单文件。将按照上面列表中的顺序指定优先级。也就是说，build 类型的清单设置会替换产品变种的清单设置，依此类推。如需了解详情，请参阅[清单合并](https://developer.android.com/studio/build/manage-manifests?hl=zh-cn#merge-manifests)。

- 同样，`values/` 目录中的文件也会合并在一起。如果两个文件同名，例如存在两个 `strings.xml` 文件，将按照上面列表中的顺序指定优先级。也就是说，在 build 类型源代码集的文件中定义的值会替换在产品变种的同一文件中定义的值，依此类推。

- `res/` 和 `asset/` 目录中的资源会打包在一起。如果在两个或更多个源代码集中定义了同名的资源，将按照上面列表中的顺序指定优先级。

- 最后，在构建应用时，Gradle 会为库模块依赖项随附的资源和清单指定最低优先级。



## 4、配置签名设置

除非您明确定义发布 build 的签名配置，否则 Gradle 不会为该 build 的 APK 或 AAB 文件签名。如果您还没有签名密钥，请参阅介绍如何使用 Android Studio [生成上传密钥和密钥库](https://developer.android.com/studio/publish/app-signing?hl=zh-cn#generate-key)的内容。

如需使用 Gradle build 配置为“release”build 类型手动进行签名配置，请执行以下操作：

1. 创建一个密钥库。**密钥库**是一个包含一组私钥的二进制文件。您必须将密钥库保存在安全可靠的地方。
2. 创建一个私钥。**私钥**用于为应用签名以进行分发，绝不能包含在应用中，也不得透露给未经授权的第三方。
3. 将签名配置添加到模块级 `build.gradle` 文件中：

```groovy
...
android {
    ...
    defaultConfig {...}
    signingConfigs { // 配置签名
        release {
            storeFile file("myreleasekey.keystore")
            storePassword "password"
            keyAlias "MyReleaseKey"
            keyPassword "password"
        }
    }
    buildTypes {
        release {
            ...
            signingConfig signingConfigs.release
        }
    }
}
```

**注意**：在 build 文件中添加发布密钥和密钥库的密码并不是一种好的安全做法。作为替代方案，您可以将构建文件配置为从环境变量获取这些密码，或让构建流程提示您输入这些密码。

如需从环境变量获取这些密码，请添加以下代码：

```groovy
storePassword System.getenv("KSTOREPWD")
keyPassword System.getenv("KEYPWD")
```

如需让构建流程在您要从命令行调用 build 时提示您输入这些密码，请添加以下代码：

```groovy
storePassword System.console().readLine("\nKeystore password: ")
keyPassword System.console().readLine("\nKey password: ")
```

完成此流程后，您可以分发您的应用并在 Google Play 上发布它。

更多详情参考官方文档：[配置 build 变体](https://developer.android.com/studio/build/build-variants?hl=zh-cn)