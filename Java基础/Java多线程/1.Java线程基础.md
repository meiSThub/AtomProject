

[TOC]

Java线程互斥与同步设计基本原则：把相同业务的处理封装到同一个类中，在这个类中完成彼此业务的互斥与同步。

# 一、开启线程的两种方式

## 1、继承Thread类

```java
public static void main(String[] args) {
    Thread thread = new Thread() {
        @Override
        public void run() {
            super.run();
            System.out.println("子线程执行：threadName=" + Thread.currentThread());
        }
    };
    thread.start();
    System.out.println("主线程执行");
}
```

日志打印：

> Task :ThreadDemo:MyClass.main()
> 主线程执行
> 子线程执行：threadName=Thread[Thread-0,5,main]

## 2、实现Runnable接口

```java
public static void main(String[] args) {
    Runnable runnable = new Runnable() {
        @Override
        public void run() {
            System.out.println("子线程执行：threadName=" + Thread.currentThread());
        }
    };
    Thread thread = new Thread(runnable);
    thread.start();

    System.out.println("主线程执行");
}
```

日志打印：

> Task :ThreadDemo:MyClass.main()
> 主线程执行
> 子线程执行：threadName=Thread[Thread-0,5,main]



## 3、两种实现的优缺点

* （1）实现Runnable接口，更加灵活，代码复用性高。
* （2）继承Thread类：从面向对象的角度说，除非你想要特殊的线程来专门处理某一类事务，否则不要实现Thread子类。

**实现Runnable接口的好处：**

1，将线程的任务从线程的子类中分离出来，进行了单独的封装，按照面向对象的思想将任务封装成对象。
2，避免了java单继承的局限性。



## 问答

**1、Thread 对象可以重复使用吗？能否调用 start()  指定新的任务给它？**

不行。一旦线程的 run() 方法完成之后，该线程就不能重新启动。事实上线程的 run() 方法执行完成之后，线程就死翘翘了。Thread 对象可能还存在堆上，如同活着的对象一般还能接收某些方法的调用，但已经永远地失去了线程的执行性，只剩下对象本身了（跟一个普通对象没有区别）。 

# 二、锁

锁的分类：

## 1、对象的锁

每个java对象都有一个锁，每个锁只有一把钥匙。通常对象都没有上锁，也没有人在乎这件事。

但如果对象有同步化方法，则线程只有在取得钥匙的情况下才能进入这些方法。也就是说并没有其它线程已经进入的情况下才能进入。

## 2、类的锁

除了对象可以有锁之外，类也有锁。当你要对静态方法做同步化时，Java 会使用类本身的锁。因此如果同一个类，有两个被同步化的静态方法，线程只有取得类的锁才能进入这些方法。

# 三、要点

1. Thread.sleep() 这个静态方法可以强制线程进入等待状态到过了设定时间为止。例如：Thread.sleep(200) 会让线程休眠200毫秒。

   200毫秒内，线程为不可执行状态。等200毫秒之后，线程才会转为可执行状态。

2. 要让对象在线程上有足够的安全性，就要判断出哪些指令不能被分割执行。这时候就需要保证操作的原子性。

3. **synchronized** 关键字可以保证操作的原子性。

   ```java
   private synchronized void increment() {
       int i = balance;
       balance = i + 1;
   }
   ```

   Increment() 方法，有三个指令：

   * 取得 balance 值
   * 计算 i+1
   * 更新 balance 值

   如果在执行完第一个指令之后，线程就休眠了，由于increment() 方法还没有执行完，所以线程不会释放锁，因此其它的线程也不可能获得锁。当该线程又恢复执行的时候，就会接着执行下面的两个指令。该方法执行完成，线程就会释放对象锁。

   虽然 increment() 方法的执行过程不是一次执行完的，不像原子操作（原子操作表示不可拆分），但最终的执行结果就跟原子操作时一样的，因此 **synchronized**关键字保证了操作的原子性 。

4. 使用 synchronized 关键字可以防止两个线程同时进入同一个对象的同一个方法。

5. 每个对象都有单一的锁，单一的钥匙。这只会在对象带有同步方法时才有实际的用途。

6. 线程尝试进入同步化的方法时必须要取得对象的锁，如果因为已经被其它的线程拿走了，那就得等。

7. 对象就算是有多个同步化过的方法，也还是只有一个锁。一旦某个线程进入该对象的同步化方法，其他线程就无法进入该对象上的任何同步化方法。

# 四、知识点

几个基本概念：

* **可⻅性**：⼀个线程对共享变量值的修改，能够及时地被其他线程看到。

* **共享变量**：如果⼀个变量在多个线程的⼯作内存中都存在副本，那么这个变量就是⼏个线程的共享变量。

* **重排序**：代码书写的顺序与实际执⾏的顺序不同，指令重排序时编译器或处理器为了提⾼程序性能做的优化。
  * 编译器优化的重排序（编译器优化）
  * 指令集并⾏重排序（处理器优化）
  * 内存系统的重排序（处理器优化）



## 1、Java内存模型

**JMM（java memory model）**JAVA 内存模型，描述线程之间如何通过内存(memory)来进⾏交互。具体说来，JVM中存在⼀个主存区（Main Memory或Java HeapMemory），对于所有线程进⾏共享，⽽每个线程⼜有⾃⼰的⼯作内存（Working Memory），⼯作内存中保存的是主存中某些变量的拷⻉，线程对所有变量的操作并⾮发⽣在主存区，⽽是发⽣在⼯作内存中，⽽线程之间是不能直接相互访问，变量在程序中的传递，是依赖主存来完成的。具体的如下图所示：

![image-20220524095150075](https://raw.githubusercontent.com/meiSThub/BlogImage/master/2022image-20220524095150075.png)

* 所有的变量都存储在主内存中（分配给进程的内存）
* 每个线程都有⾃⼰独⽴的⼯作内存，⾥⾯保存该线程使⽤到的变量的副本（主内存中该变量的⼀份拷⻉），会产生副本的变量都是共享变量。

主内存主要对应于java堆中对象的实例数据部分，⽽⼯作内存则对应于虚拟机栈中的部分区域；从更底层来说，主内存就是硬件的内存，⽽为了获取更好的运⾏速度，虚拟机及硬件系统可能会让⼯作内存优先存储于寄存器和⾼速缓存



### **JMM**有两条规定：

* （1）线程对**共享变量**的所有操作都必须在⾃⼰的⼯作内存中进⾏，不能直接从主内存中读写

* （2）不同线程之间⽆法直接访问其他线程⼯作内存中的变量，线程间变量值的传递需要通过主内存来完成。

  

## 2、共享变量可⻅性实现的原理

**导致共享变量在线程间不可⻅的主要原因**：

*  （1）线程的交叉执⾏；
* （2）重排序结合线程的交叉执⾏；
* （3）共享变量更新后的值没有在⼯作内存与主内存之间及时更新。

**要实现共享变量的可⻅性，必须保证两点**：

* （1）线程修改后的共享变量值能够及时从⼯作内存刷新到主内存中；

* （2）其他线程能够及时把**共享变量**的最新值从主内存更新到⾃⼰的⼯作内存中。

  

## 2、JVM关于synchronized的两条规定

* 线程解锁前，必须把共享变量的最新值刷新到主内存中
* 线程加锁前，将清空⼯作内存中**共享变量**的值，在使⽤**共享变量**时需要从主内存中重新读取最新的值（注意：加锁和解锁需要是同⼀把锁）

线程解锁前对共享变量的修改在下次加锁时对其他线程可⻅。

## 3、线程执⾏互斥代码的过程:

1. 获得互斥锁
2. 清空⼯作内存
3. 从主内存拷⻉变量的最新副本到⼯作内存
4. 执⾏代码
5. 将更改后的共享变量的值刷新到主内存
6. 释放互斥锁



## 4、多个线程访问共享对象和数据的方式：

1. 如果每个线程执行的代码相同，可以使用同一个Runnable对象，这个Runnable对象中有那个共享数据，例如，卖票系统就可以这么做。
2. 如果每个线程执行的代码不同，这个时候需要不同的Runnable对象，有如下两种方式来实现这些Runnable对象之间的数据共享：
   * 将共享数据封装在另外一个对象中，然后将这个对象逐一传递给各个Runnable对象。每个线程对共享数据的操作方法也分配到那个对象身上去完成，这样容易实现对该数据进行的各个操作的互斥和通信。
   * 将这些Runnable对象作为某一个类中的内部类，共享数据作为这个外部类中的成员变量，每个线程对共享数据的操作方法也分配给外部类，一边实现对共享数据进行各个操作的互斥和通信，作为内部类的各个Runnable对象调用外部类的这些方法。
   * 上面两种方式的组合：将共享数据封装在另外一个对象中，每个线程对共享数据的操作方法也分配到那个对象身上去完成，对象作为这个外部类中的成员变量或者方法中的局部变量，每个线程的Runnable对象作为外部类中的成员内部类或局部内部类
   * 总之，要同步互斥的几段代码最好是分别放在几个独立的方法中，这些方法再放在同一个类中，这样比较容易实现他们之间的同步互斥和通信。

## 5、Volatile 变量的更新读取过程

线程写volatile变量的过程：

* （1）改变线程⼯作内存中volatile变量副本的值
* （2）将改变后的副本的值从⼯作内存刷新到主内存

线程读volatile变量的过程：

* （1）从主内存中读取volatile变量的最新值到线程的⼯作内存中
* （2）从⼯作内存中读取volatile变量的副本

## 6、**volatile**使⽤注意事项

要在多线程中安全的使⽤volatile变量，必须同时满⾜：

（1）对变量的写⼊操作不依赖其当前值

```
不满⾜：number++，conut = conut *5等
满⾜：boolean变量，记录温度变化的变量等
```

（2）该变量没有包含在具有其他变量的不等式中

```
不满⾜：不等式 low < up
```

## 7、**synchronized**和**volatile**⽐较

* volatile 不需要加锁，⽐synchronized更轻量级，不会阻塞线程。并且volatile只能修饰变量，⽽synchronized可以修饰⽅法，以及代码块。
* 从内存可⻅性⻆度，volatile读相当于加锁，volatile写相当于解锁
* synchronized既能保证可⻅性，⼜能保证原⼦性，⽽volatile只能保证可⻅性，⽆法保证原⼦性。























