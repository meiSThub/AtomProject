Java线程互斥与同步设计基本原则：把相同业务的处理封装到同一个类中，在这个类中完成彼此业务的互斥与同步。





### 多个线程访问共享对象和数据的方式：

1. 如果每个线程执行的代码相同，可以使用同一个Runnable对象，这个Runnable对象中有那个共享数据，例如，卖票系统就可以这么做。
2. 如果每个线程执行的代码不同，这个时候需要不同的Runnable对象，有如下两种方式来实现这些Runnable对象之间的数据共享：
   * 将共享数据封装在另外一个对象中，然后将这个对象逐一传递给各个Runnable对象。每个线程对共享数据的操作方法也分配到那个对象身上去完成，这样容易实现对该数据进行的各个操作的互斥和通信。
   * 将这些Runnable对象作为某一个类中的内部类，共享数据作为这个外部类中的成员变量，每个线程对共享数据的操作方法也分配给外部类，一边实现对共享数据进行各个操作的互斥和通信，作为内部类的各个Runnable对象调用外部类的这些方法。
   * 上面两种方式的组合：将共享数据封装在另外一个对象中，每个线程对共享数据的操作方法也分配到那个对象身上去完成，对象作为这个外部类中的成员变量或者方法中的局部变量，每个线程的Runnable对象作为外部类中的成员内部类或局部内部类
   * 总之，要同步互斥的几段代码最好是分别放在几个独立的方法中，这些方法再放在同一个类中，这样比较容易实现他们之间的同步互斥和通信。

# 一、开启线程的两种方式

### 1、继承Thread类

```java
public static void main(String[] args) {
    Thread thread = new Thread() {
        @Override
        public void run() {
            super.run();
            System.out.println("子线程执行：threadName=" + Thread.currentThread());
        }
    };
    thread.start();
    System.out.println("主线程执行");
}
```

日志打印：

> Task :ThreadDemo:MyClass.main()
> 主线程执行
> 子线程执行：threadName=Thread[Thread-0,5,main]

### 2、实现Runnable接口

```java
public static void main(String[] args) {
    Runnable runnable = new Runnable() {
        @Override
        public void run() {
            System.out.println("子线程执行：threadName=" + Thread.currentThread());
        }
    };
    Thread thread = new Thread(runnable);
    thread.start();

    System.out.println("主线程执行");
}
```

日志打印：

> Task :ThreadDemo:MyClass.main()
> 主线程执行
> 子线程执行：threadName=Thread[Thread-0,5,main]



### 3、两种实现的优缺点

* （1）实现Runnable接口，更加灵活，代码复用性高。
* （2）继承Thread类：从面向对象的角度说，除非你想要特殊的线程来专门处理某一类事务，否则不要实现Thread子类。

**实现Runnable接口的好处：**

1，将线程的任务从线程的子类中分离出来，进行了单独的封装，按照面向对象的思想将任务封装成对象。
2，避免了java单继承的局限性。



### 问答

**1、Thread 对象可以重复使用吗？能否调用 start()  指定新的任务给它？**

不行。一旦线程的 run() 方法完成之后，该线程就不能重新启动。事实上线程的 run() 方法执行完成之后，线程就死翘翘了。Thread 对象可能还存在堆上，如同活着的对象一般还能接收某些方法的调用，但已经永远地失去了线程的执行性，只剩下对象本身了（跟一个普通对象没有区别）。 



## 二、锁

锁的分类：

### 1、对象的锁

每个java对象都有一个锁，每个锁只有一把钥匙。通常对象都没有上锁，也没有人在乎这件事。

但如果对象有同步化方法，则线程只有在取得钥匙的情况下才能进入这些方法。也就是说并没有其它线程已经进入的情况下才能进入。

#### 2、类的锁

除了对象可以有锁之外，类也有锁。当你要对静态方法做同步化时，Java 会使用类本身的锁。因此如果同一个类，有两个被同步化的静态方法，线程只有取得类的锁才能进入这些方法。



## 三、要点

1. Thread.sleep() 这个静态方法可以强制线程进入等待状态到过了设定时间为止。例如：Thread.sleep(200) 会让线程休眠200毫秒。

   200毫秒内，线程为不可执行状态。等200毫秒之后，线程才会转为可执行状态。

2. 要让对象在线程上有足够的安全性，就要判断出哪些指令不能被分割执行。这时候就需要保证操作的原子性。

3. **synchronized** 关键字可以保证操作的原子性。

   ```java
   private synchronized void increment() {
       int i = balance;
       balance = i + 1;
   }
   ```

   Increment() 方法，有三个指令：

   * 取得 balance 值
   * 计算 i+1
   * 更新 balance 值

   如果在执行完第一个指令之后，线程就休眠了，由于increment() 方法还没有执行完，所以线程不会释放锁，因此其它的线程也不可能获得锁。当该线程又恢复执行的时候，就会接着执行下面的两个指令。该方法执行完成，线程就会释放对象锁。

   虽然 increment() 方法的执行过程不是一次执行完的，不像原子操作（原子操作表示不可拆分），但最终的执行结果就跟原子操作时一样的，因此 **synchronized**关键字保证了操作的原子性 。

4. 使用 synchronized 关键字可以防止两个线程同时进入同一个对象的同一个方法。

5. 每个对象都有单一的锁，单一的钥匙。这只会在对象带有同步方法时才有实际的用途。

6. 线程尝试进入同步化的方法时必须要取得对象的锁，如果因为已经被其它的线程拿走了，那就得等。

7. 对象就算是有多个同步化过的方法，也还是只有一个锁。一旦某个线程进入该对象的同步化方法，其他线程就无法进入该对象上的任何同步化方法。



































