

[TOC]



# 一、概念

------



## 1、**插值器**：



定义：根据时间流逝的百分比来计算出当前属性值改变的百分比



如系统自带的有：

* **LinearInterpolator**（线性插值器：匀速动画）
* **AccelerateDecelerateInterpolator**：加速减速插值器，即动画两头慢，中间快
* **DecelerateInterpolator**：减速插值器，动画越来越慢



## 2、**估值器**：



定义：根据当前属性改变的百分比来计算出改变后的属性值。其中属性改变的百分比是由**插值器**得到的。



如系统自带的估值器有：

* **IntEvaluator**：整型属性估值器

* **FloatEvaluator**：浮点型估值器

* **ArgbEvaluator**：颜色估值器

  

**动画默认的刷新率为10ms/帧。**





## 3、自定义一个估值器，View按照抛物线平移：



```kotlin
fun evaluator(view: View) {

    var animator = ObjectAnimator()
    animator.duration = 400
    animator.setObjectValues(PointF(0f, 0f))
    val pointF = PointF()

  // 自定义估值器
    animator.setEvaluator(object : TypeEvaluator<PointF> {

        override fun evaluate(fraction: Float, startValue: PointF?, endValue: PointF?): PointF {
            // 实现具体的估值算法
            // 因为要计算抛物线的轨迹，这里就模仿一个有水平速度的自由落体的物体运动轨迹

            var time = fraction * 5f
            var x = startValue?.x ?: 0 + time * 100 // 假设水平速度为100
            var y = startValue?.y ?: 0 + 9.8f * time * time * 2
            Log.i(TAG, "evaluate: x=$x;y=$y ;fraction=$fraction")
            pointF.x = x
            pointF.y = y
            return pointF
        }
    })
    animator.addUpdateListener {
        var pointF: PointF = it.animatedValue as PointF
        view.translationX = pointF.x
        view.translationY = pointF.y
    }
    animator.start()
}
```





# 二、系统常用的插值器与估值器源码分析

------



## 1、插值器：

### 1-1、加速插值器：AccelerateInterpolator

```java
/**
* 加速插值器
*/
public class AccelerateInterpolator extends BaseInterpolator implements NativeInterpolator {
    private final float mFactor;
    private final double mDoubleFactor;

    public AccelerateInterpolator() {
        mFactor = 1.0f;
        mDoubleFactor = 2.0;
    }

    public AccelerateInterpolator(float factor) {
        mFactor = factor;
        mDoubleFactor = 2 * mFactor;
    }

    public AccelerateInterpolator(Context context, AttributeSet attrs) {
        this(context.getResources(), context.getTheme(), attrs);
    }

    /** @hide */
    public AccelerateInterpolator(Resources res, Theme theme, AttributeSet attrs) {
        TypedArray a;
        if (theme != null) {
            a = theme.obtainStyledAttributes(attrs, R.styleable.AccelerateInterpolator, 0, 0);
        } else {
            a = res.obtainAttributes(attrs, R.styleable.AccelerateInterpolator);
        }

        mFactor = a.getFloat(R.styleable.AccelerateInterpolator_factor, 1.0f);
        mDoubleFactor = 2 * mFactor;
        setChangingConfiguration(a.getChangingConfigurations());
        a.recycle();
    }

  // 主要看这个方法，
    public float getInterpolation(float input) {
        if (mFactor == 1.0f) {
            return input * input;
        } else {
            return (float)Math.pow(input, mDoubleFactor);
        }
    }

    /** @hide */
    @Override
    public long createNativeInterpolator() {
        return NativeInterpolatorFactory.createAccelerateInterpolator(mFactor);
    }
}
```



### 1-2、加速减速插值器：AccelerateDecelerateInterpolator

```java
/**
 * 加速减速插值器
 */
@HasNativeInterpolator
public class AccelerateDecelerateInterpolator extends BaseInterpolator
        implements NativeInterpolator {
    public AccelerateDecelerateInterpolator() {
    }

    @SuppressWarnings({"UnusedDeclaration"})
    public AccelerateDecelerateInterpolator(Context context, AttributeSet attrs) {
    }

    public float getInterpolation(float input) {
        return (float)(Math.cos((input + 1) * Math.PI) / 2.0f) + 0.5f;
    }

    /** @hide */
    @Override
    public long createNativeInterpolator() {
        return NativeInterpolatorFactory.createAccelerateDecelerateInterpolator();
    }
}
```



## 2、估值器：

### 2-1、整型估值器：IntEvaluator

```java
/**
 * 整型估值器
 */
public class IntEvaluator implements TypeEvaluator<Integer> {

    /**
    * 根据动画的当前进度，计算当前的值
     */
    public Integer evaluate(float fraction, Integer startValue, Integer endValue) {
        int startInt = startValue;
        return (int)(startInt + fraction * (endValue - startInt));
    }
}
```



### 2-2、浮点型估值器：FloatEvaluator

```java
/**
 * 浮点型估值器
 */
public class FloatEvaluator implements TypeEvaluator<Number> {

    /**
     * 跟整型估值器一样，根据动画当前进度计算当前的属性值
     */
    public Float evaluate(float fraction, Number startValue, Number endValue) {
        float startFloat = startValue.floatValue();
        return startFloat + fraction * (endValue.floatValue() - startFloat);
    }
}
```



### 2-3、颜色估值器：ArgbEvaluator

```java
/**
 * 计算颜色值
 */
public class ArgbEvaluator implements TypeEvaluator {
    
    /**
     * This function returns the calculated in-between value for a color
     * given integers that represent the start and end values in the four
     * bytes of the 32-bit int. Each channel is separately linearly interpolated
     * and the resulting calculated values are recombined into the return value.
     *
     * @param fraction The fraction from the starting to the ending values
     * @param startValue A 32-bit int value representing colors in the
     * separate bytes of the parameter
     * @param endValue A 32-bit int value representing colors in the
     * separate bytes of the parameter
     * @return A value that is calculated to be the linearly interpolated
     * result, derived by separating the start and end values into separate
     * color channels and interpolating each one separately, recombining the
     * resulting values in the same way.
     */
    public Object evaluate(float fraction, Object startValue, Object endValue) {
        int startInt = (Integer) startValue;
      // 取出开始颜色值的各个色段值，
        float startA = ((startInt >> 24) & 0xff) / 255.0f;// 开始颜色的透明度
        float startR = ((startInt >> 16) & 0xff) / 255.0f;// 开始颜色的红色值
        float startG = ((startInt >>  8) & 0xff) / 255.0f;// 开始颜色的绿色值
        float startB = ( startInt        & 0xff) / 255.0f;// 开始颜色的蓝色值

        int endInt = (Integer) endValue;
        float endA = ((endInt >> 24) & 0xff) / 255.0f;// 结束颜色的透明度
        float endR = ((endInt >> 16) & 0xff) / 255.0f;// 结束颜色的红色值
        float endG = ((endInt >>  8) & 0xff) / 255.0f;// 结束颜色的绿色值
        float endB = ( endInt        & 0xff) / 255.0f;// 结束颜色的蓝色值

        // convert from sRGB to linear
        startR = (float) Math.pow(startR, 2.2);// 求 红色的 2.2次方
        startG = (float) Math.pow(startG, 2.2);// 求绿色的2.2次方
        startB = (float) Math.pow(startB, 2.2);// 求蓝色的2.2次方

        endR = (float) Math.pow(endR, 2.2);
        endG = (float) Math.pow(endG, 2.2);
        endB = (float) Math.pow(endB, 2.2);

        // compute the interpolated color in linear space
        float a = startA + fraction * (endA - startA);// 根据进度值，求当前透明度
        float r = startR + fraction * (endR - startR);// 根据进度值，求当前的红色值
        float g = startG + fraction * (endG - startG);// 根据进度值，求当前的绿色值
        float b = startB + fraction * (endB - startB);// 根据进度值，求当前的蓝色值

        // convert back to sRGB in the [0..255] range
        a = a * 255.0f;
        r = (float) Math.pow(r, 1.0 / 2.2) * 255.0f;// 红色值的 1/2.2次方 在乘以255，确保色值不会超过255
        g = (float) Math.pow(g, 1.0 / 2.2) * 255.0f;
        b = (float) Math.pow(b, 1.0 / 2.2) * 255.0f;

      // 根据求的的argb色值，封装成新的颜色整数值
        return Math.round(a) << 24 | Math.round(r) << 16 | Math.round(g) << 8 | Math.round(b);
    }
}
```



# 三、对任意属性做动画

------



1. **属性动画的原理**

   属性动画要求动画作用的对象提供该属性的get和set方法，属性动画根据外界传递的该属性的初始值和最终值，以动画的效果多次去调用set方法，每次传递给set方法的值都不一样，确切来说是随着时间的推移，所传递的值越来越接近最终值。



2. **属性动画生效的条件：**

   * object必须要提供set方法，如果动画的时候没有传递初始值，还要提供get方法，因为系统要去取属性的初始值，这个时候如果没有get方法，就会崩溃。

   * object通过set方法对属性做的改变，必须能够通过某种方法反映出来，比如会使UI重绘等，否则动画看不出效果，但不会崩溃。

     

   **结论：**属性动画要求对象的该属性必须有set方法和get方法。否则执行属性动画会报错。



3. 针对没有get和set方法的对象如何使用属性动画的**解决方案**
   * 给对象加上get和set方法，如果有权限的话；
   * 用一个类来包装原始对象，间接为其提供get和set方法；
   * 来用ValueAnimator，监听动画的过程，自己实现属性的改变；



针对上面提出的三种解决方法，下面给出具体的介绍：

* **方案一**：**给对象加上get和set方法**

  一般情况下，我们是没有办法为SDK里面的类增加set和get方法的，但kotlin可以通过扩展方法的方式实现。

* **方案二**：**通过一个包装类封装set和get方法**

  如：为View增加一个获取宽高和设置宽高的包装类

  ```kotlin
  /**
   * @desc View包装类
   * @desired
   */
  class ViewWrapper(private var mTarget: View) {
  
      /**
       * 获取宽度
       */
      fun getWidth(): Int {
          return mTarget.layoutParams.width
      }
  
      /**
       * 获取高度
       */
      fun getHeight(): Int {
          return mTarget.layoutParams.height
      }
  
      /**
       * 设置宽度
       */
      fun setWidth(width: Int) {
          mTarget.layoutParams.width = width
          mTarget.requestLayout()
      }
  
      /**
       * 设置高度
       */
      fun setHeight(height: Int) {
          mTarget.layoutParams.height = height
          mTarget.requestLayout()
      }
  
  }
  ```

  这样，当通过属性动画去修改View的宽高的时候，可以这样做：

  ```kotlin
  fun increaseWidth(view: View) {
      var measureWidth = view.measuredWidth
      var wrapper = ViewWrapper(view)
      var objectAnimator = ObjectAnimator.ofInt(wrapper, "width", measureWidth, measureWidth + 200)
      objectAnimator.duration = 300
      objectAnimator.start()
  }
  ```



* **方案三：采用ValueAnimator，监听动画过程，自己实现属性的改变**

  ```kotlin
  fun evaluator(view: View) {
      var measureWidth = view.measuredWidth
      var valueAnimator = ValueAnimator.ofInt(measureWidth, measureWidth + 200)
      valueAnimator.duration = 300
      valueAnimator.addUpdateListener {
        var width = it.animatedValue as Int
        var layoutParams = view.layoutParams
        layoutParams.width = width
        view.layoutParams = layoutParams
      }
      valueAnimator.start()
  }
  ```

  实现的效果跟方案二是一模一样的。



