

### 一、**属性动画原理描述：**



​	属性动画要求动画作用的对象提供该属性的set和get方法，属性动画根据你传递的该属性的初始值和最终值，以动画的效果多次去调用set方法。



​	每次传递给set方法的值都不一样，确切的说是随着时间的推移，所传递的值越来越接近最终值。



​	如果动画的时候没有传递初始值，那么还要提供get方法，因为系统要去获取属性的初始化值。





### 二、属性动画源码分析

如下面的属性动画：

```kotlin
/**
 * 通过一个包装类，实现set和get方法，从而实现属性动画
 */
fun viewWrapper(view: View) {
    var measureWidth = view.measuredWidth
    var wrapper = ViewWrapper(view)
    var objectAnimator = ObjectAnimator.ofInt(wrapper, "width", measureWidth, measureWidth + 200)
    objectAnimator.duration = 300
    objectAnimator.start()
}
```



下面就从start方法为入口，分析一下属性动画的具体实现。



**ObjectAnimator**的**start**方法：

```java
@Override
public void start() {
  // 执行了一个取消操作，判断将要执行的动画，是否与正在执行的动画，等待的动画相同，如果相同，则取消正在执行的动画
    AnimationHandler.getInstance().autoCancelBasedOn(this);
    super.start();// 执行父类的start方法
}
```



ObjectAnimator是继承与ValueAnimator的，所以看下ValueAnimator的start方法：

```java
@Override
public void start() {
    start(false);
}

private void start(boolean playBackwards) {
    if (Looper.myLooper() == null) {
      throw new AndroidRuntimeException("Animators may only be run on Looper threads");
    }
    mReversing = playBackwards;
    mSelfPulse = !mSuppressSelfPulseRequested;
    // Special case: reversing from seek-to-0 should act as if not seeked at all.
    if (playBackwards && mSeekFraction != -1 && mSeekFraction != 0) {
      if (mRepeatCount == INFINITE) {
        // Calculate the fraction of the current iteration.
        float fraction = (float) (mSeekFraction - Math.floor(mSeekFraction));
        mSeekFraction = 1 - fraction;
      } else {
        mSeekFraction = 1 + mRepeatCount - mSeekFraction;
      }
    }
    mStarted = true;
    mPaused = false;
    mRunning = false;
    mAnimationEndRequested = false;
    // Resets mLastFrameTime when start() is called, so that if the animation was running,
    // calling start() would put the animation in the
    // started-but-not-yet-reached-the-first-frame phase.
    mLastFrameTime = -1;
    mFirstFrameTime = -1;
    mStartTime = -1;
    addAnimationCallback(0);

    if (mStartDelay == 0 || mSeekFraction >= 0 || mReversing) {
      // If there's no start delay, init the animation and notify start listeners right away
      // to be consistent with the previous behavior. Otherwise, postpone this until the first
      // frame after the start delay.
      startAnimation();
      if (mSeekFraction == -1) {
        // No seek, start at play time 0. Note that the reason we are not using fraction 0
        // is because for animations with 0 duration, we want to be consistent with pre-N
        // behavior: skip to the final value immediately.
        setCurrentPlayTime(0);
      } else {
        setCurrentFraction(mSeekFraction);
      }
    }
}
```